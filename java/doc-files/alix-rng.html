<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-type" content="text/html; charset=UTF-8"/>
    <style type="text/css"> /* keep file XML valid, maybe included by xsl:document() */
/*

Copyright © 2004-2017 Frédéric Glorieux
license : APACHE 2.0 http://www.apache.org/licenses/LICENSE-2.0
&lt;frederic.glorieux@fictif.org&gt;

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/
/*
Classes for documented XML files by xmldoc transformations
*/

section, nav, article, aside, hgroup, header, footer, figure, figcaption { display:block;}
* {-moz-box-sizing: border-box; -ms-box-sizing: border-box; -webkit-box-sizing: border-box; box-sizing: border-box;}

/** Fonts */

body.xmldoc, table.facs caption { font-family:"Lucida Sans Unicode", "Lucida Grande", sans-serif;font-size:13px;margin:0;}
body.item {padding:2em;}
body.nav{padding:0;margin:1ex;}
body.xmldoc #nav, body.xmldoc #header {font-family:Arial, sans-serif;font-size:13px;}

/** simple HTML, with body class protection if css imported (in html tagname order) */

body.xmldoc a {color:#226; text-decoration:none;}
body.xmldoc a:hover { text-decoration:underline;}
body.xmldoc fieldset { margin:1em 0 1ex 0; padding:0 1ex 0 1ex; border:1px dotted #363; -moz-border-radius:1ex; -webkit-border-radius:1ex; white-space:normal;}
body.xmldoc p {}
body.xmldoc h1 {text-align:center; line-height:105%;}
body.xmldoc h3 {border-bottom:1px solid #336699; padding-left: 1em; margin-top:2em; margin-bottom:1em;}
body.xmldoc table {font-size:inherit;}

/* Global layout */
html{height:100%;}
body.xmldoc{position:relative;}
body.xmldoc #article { padding:0; margin:3ex 5em 5em 30%; min-height:500px;}
body.xmldoc #header {position:absolute;background:#DADADA;top:0;left:0;right:0;padding:0 1ex;}
body.xmldoc #footer {position:absolute;background:#DADADA;bottom:-1px;left:0;right:0;padding:0 1ex;} /* need container with position :relative */
body.xmldoc #footer img {margin:-4px;}
body.xmldoc #nav { top:0; position:fixed; padding:0 3px 2em 11px; height:100%; overflow:auto; width:27%; color:black; margin:0 0 0 0; border-right:solid 1px #b3b3b3; }
body.xmldoc #nav header, body.nav header { padding:1ex 0;font-style:normal; font-weight:bold;}
.index div {line-height:100%;margin:0.8ex 0;}

/** generic classes */
.pre {white-space: pre-wrap;}
.tree ul { padding:0; margin:0; padding-left:1em; }
body.xmldoc ul.tree ul { padding-left:1ex; margin-left:1em;}

/* xml2html.xsl, documented XML source */

.example { background-color: #FFFFFF; background-image: -webkit-gradient(linear, left top, right top,from(#FFFFFF),to(#F8F8F8)); background-image: -webkit-linear-gradient(left, #FFFFFF, #F8F8F8); background-image: -moz-linear-gradient(left, #FFFFFF, #F8F8F8); background-image: -ms-linear-gradient(left, #FFFFFF, #F8F8F8); background-image:      -o-linear-gradient(left, #FFFFFF, #F8F8F8); background-image: linear-gradient(left, #FFFFFF, #F8F8F8); border-left:1px dotted #808080; padding:1ex 1em; margin:0;}
.xml { line-height:105%; text-align:left;}
.xml  a { text-decoration:none; border-bottom:none; border:none; padding:0;}
.xml a.val { color:#0000FF; }
.xml a.val:hover { text-decoration:underline; border:none; }
a.xsl  { color:#669966; font-weight:100;}
a:hover.xsl, a:hover.rdf { background:#0000FF; color:white; }
a.html, a.dc { color:#FF0000; font-weight:bold;}
a:hover.html, a:hover.dc, a:hover.template { background:red; color:white; }
a.template { font-family: Verdana, arial, sans-serif; font-weight:bold; }
.xml .el, .xml  a.el { font-weight:bold; font-family: "Lucida Console", Courier, "MS Courier New", monospace; text-decoration:none; color:#040; border:none; }
.xml a:hover.el, .xml a:hover.att { background:#8080FF; color:#FFFFFF; }
.xml .att { font-family:Arial, sans-serif; font-weight:100; }
.xml a.att { font-family:Arial, sans-serif; color:#444;}
.xml .open, .xml .close, .xml .tag { margin:0; font-family:monospace, sans-serif; color:#383; }
.xml .fold {color:#666666; }
.xml .pi { color:#008000; font-weight: bold; }
.xml .val, .xml .cdata { font-weight:normal; margin:0; padding:0; }
.xml .comment, .xml .comment code { font-size:12px; line-height:125%; background:#FFE; color:#666; }
.xml  pre.comment { margin:0; padding:0 1em;}
.xml .comment { font-family:monospace; color:#000; }
fieldset.comment pre {color:#008;}
div.comment {white-space: normal;}
dd.code { margin:0 !important; padding:0 !important; padding-left:1em !important; border-left: 1px dotted #808080;}
.pre .text { background:#EEF; font-family:serif; color:#000;}
.xml span.text, .xml .val, .xml .cdata { color:#444;}
.xml .cdata { color:red}
.xml .ns { color:#000080; font-weight:100;}
dt { font-weight:bold;}
dl.xml { margin:0; padding:0;}
dl.xml dt { font-weight:normal; }
details.source { margin-left:1em; float:right; max-width:60%; background:#FFFFFF;}
details.source summary { float:right; display:inline; text-align:right;}
details &gt; * { display:none;}
details.minus &gt; * { display:block;}

/** Relax-NG */

section.attribute { margin-top:1em; }
section.define, section.element { margin-top:2em; }
section.rng { margin:2em 0 0 0;}
section.rng section.rng header { padding-left:2em;}
section.rng section.rng section.rng header { padding-left:4em;}
section.rng section.rng section.rng section.rng header { padding-left:6em;}
header.rng { font-size:110%; margin-bottom:1ex; padding:0; border:none;}
header.rng a { color:#77A; font-weight:bold;}
header.attribute { color:#666;}
/* entry in a table */
table.grammar { background-color:#F8F8F8; background-image: -webkit-gradient(linear, left top, right top,from(#FFFFFF),to(#F8F8F8)); background-image: -webkit-linear-gradient(left, #FFFFFF, #F8F8F8); background-image: -moz-linear-gradient(left, #FFFFFF, #F8F8F8); background-image: -ms-linear-gradient(left, #FFFFFF, #F8F8F8); background-image: -o-linear-gradient(left, #FFFFFF, #F8F8F8); background-image: linear-gradient(left, #FFFFFF, #F8F8F8); border-collapse:collapse; width:100%; line-height:105%; border-left:1px dotted #808080;margin-bottom:1em;}
table.grammar tt, table.grammar em {color:#000;}
table.grammar td { padding:0.5ex 1ex; line-height:1.1em; border-bottom:1px dotted #999999;vertical-align:top;}
table.grammar th { font-family:Helvetica, Arial, "DejaVu Sans Light ", sans-serif; font-size:12px; width:10ex; vertical-align:top; padding:0.5ex 1ex; background:#DADADA; border-bottom:1px solid #FFFFFF; font-weight:normal;}
table.attributes td {padding:0 0.2ex;line-height:100%;border:none;}
table.attributes td.name {text-align:right;}
.xmldoc a.required {color:#000;font-weight:bold;}
.grammar a { font-family:Helvetica, Arial, "DejaVu Sans Light ", sans-serif; color:#315BA7; border:none;}
.grammar a.define, .grammar a.ref { color:#000; font-style:italic; font-family:serif;}
td.children div, td.usage div {display:inline}
p.cf {margin-top:0;}
/* att values */
ul.values {  margin-top:0; margin-bottom:0; padding-top:0; margin-bottom:0;}
.value{color:#000;}
.value div.documentation {font-style:italic}
/* hide/show macro compact view */
.grammar a.toggle { color:#000; cursor:pointer;}
a.toggle:hover { text-decoration:none !important; background:#336699; color:#FFFFFF;}
span.more span.refin { display:none;}
span.less span.refin {display:block;}
span.less span.more span.refin {display:none;}
span.refin { margin-left:0.5ex; border-left:1px dotted #888; padding-left:2ex;}
div.compact {padding-left:1ex;}
div.compact ul { margin-top:0; margin-bottom:0; padding-top:0; padding-bottom:0;}
/* image example */
table.facs { font-family:serif; margin-top:2em; margin-bottom:2em; border:1px dotted #808080; padding-left:2em; padding-right:2em;}
table.facs td { vertical-align:top;}
table.facs caption { background:#DADADA;}
table.facs p { margin-top:2ex; margin-bottom:2ex;}

/** xsl2html.xsl, documented transformation */
.transform a {border:none;}
.match p, .result p { text-indent:1em; line-height:110%; margin:0 0 0.5ex 0; }
.xsl-var { margin-top:1ex;}
.output { color:#961716; font-family: "Lucida Console", Courier, "MS Courier New", monospace; font-size:13px; line-height:110%; text-indent:0; text-align:left;}
.template { margin: 1em 0 0 0; clear:both;}
.template header { border:none; padding:0; border-bottom:#888 1px solid;}

/* PHP code */
a.function, .php b.construct, .php var {font-family:Frutiger,"Deja Vu Sans",Helvetica,sans-serif; }
pre.php { white-space: pre-wrap; font-size:14px; color:red; }
code.function {color:#A82C37; }
span.function { font-family:Frutiger,"Deja Vu Sans",Helvetica,sans-serif; color:#000;}
a.function:hover {text-decoration:underline; }
.php b.construct { color:#000; }
code.string { color:#060; }
code.integer { color:#FF0000; font-weight:bold; }
code.php-tag { color:#FF0000; }
code.numeric { color:#FF0000; font-weight:bold; }
code.constant { color:#000000; }
tt.op { background:none repeat scroll 0 0 #EEEEEE; color:#000000; }
code.defined { color:red; }
code.whitespace { white-space:pre; }
code.curly { background:none repeat scroll 0 0 #FFAAAA;}
code.parenthese { background:none repeat scroll 0 0 #AAFFAA; }
code.square { background:none repeat scroll 0 0 #AAAAFF; }
code.error-control { background:none repeat scroll 0 0 #FF0000; font-weight:bold; }

@media print {
  #nav {display:none;}
  #article {margin:0px !important; padding:0px; }
  table.grammar  td, table.grammar  th { border:1px dotted #808080; }
}
/* keep file XML valid, maybe included by xsl:document() */
</style>
  </head>
  <body class="xmldoc rng">
    <nav id="nav">
      <p> </p>
      <a style="font-weight:bold; color:#000000;" href="#idm1">Alix, schema of xml to ingest</a>
      <section class="index"><header>Elements (11)</header><div><b>B</b>. &lt;<a href="#el_book">book</a>&gt;  </div> <div><b>C</b>. &lt;<a href="#el_chapter">chapter</a>&gt;  </div> <div><b>D</b>. &lt;<a href="#el_document">document</a>&gt;  </div> <div><b>F</b>. &lt;<a href="#el_field">field<small class="att"> type="text"</small></a>&gt; &lt;<a href="#el_field_2">field<small class="att"> type="meta"</small></a>&gt; &lt;<a href="#el_field_3">field<small class="att"> type="store"</small></a>&gt; &lt;<a href="#el_field_4">field<small class="att"> type="int"</small></a>&gt; &lt;<a href="#el_field_5">field<small class="att"> type="facet"</small></a>&gt; &lt;<a href="#el_field_6">field<small class="att"> type="facets"</small></a>&gt;  </div> <div><b>S</b>. &lt;<a href="#el_set">set</a>&gt;  </div> </section>
      <section class="index"><header>Attributes</header><div><b>N</b>. @<a href="#att_name">name</a>  </div> </section>
      <section class="index"><header>Macros</header><div><b>F</b>. <a href="#def_field">field</a>()  </div> <div><b>X</b>. <a href="#def_xml">xml</a>()  </div> </section>
      <p> </p>
    </nav>
    <article id="article" class="grammar">
      <h1 id="idm2">Alix, schema of xml to ingest</h1>
      <div>
        <p>
      This Relax-NG schema defines the XML tags understood by Alix to ingest text documents (articles, books…) in a <a href="https://lucene.apache.org/core/">Lucene</a> index.
    </p>
        <p>Let's start by the kind of XML understood by Alix.</p>
        <figure class="xml example" id="ex_1">
          <dl class="xml ">
            <dt class="open"><a class="fold" tabindex="1">&lt;</a><a class="el" href="#el_set">alix:set</a><div class="xmlns"> <span class="att">xmlns:<span class="ns">alix</span></span>="<code class="val">http://alix.casa</code>"</div>&gt;</dt>
            <dd class="code">
              <dl class="xml ">
                <dt class="open"><a class="fold" tabindex="1">&lt;</a><a class="el" href="#docid1">alix:document</a> <b class="xml att">xml:id</b>="<code class="val">docid1</code>"&gt;</dt>
                <dd class="code">
                  <div class="">
                    <span class="open">&lt;<a class="el" href="#el_field" title="&#10;Text to search with advanced lexical features (lemma, co-occurrences…).&#10;XML tags are allowed, well-formedness is not required, so HTML ready to display could be sent.&#10;Content is also available as a stored field for display, hilite of occurrences found, relevant excerpts.&#10;This type is quite heavy (positions, offsets, term vectors…).&#10;If you need a simple token search, prefer @type=&quot;meta&quot;.&#10;      ">alix:field</a> <b class="alix att">name</b>="<code class="val">title</code>" <b class="alix att">type</b>="<code class="val">text</code>"&gt;</span>
                    <span class="text">First document</span>
                    <span class="close">&lt;/<a class="el" href="#el_field" title="&#10;Text to search with advanced lexical features (lemma, co-occurrences…).&#10;XML tags are allowed, well-formedness is not required, so HTML ready to display could be sent.&#10;Content is also available as a stored field for display, hilite of occurrences found, relevant excerpts.&#10;This type is quite heavy (positions, offsets, term vectors…).&#10;If you need a simple token search, prefer @type=&quot;meta&quot;.&#10;      ">alix:field</a>&gt;</span>
                  </div>
                  <div class="open ">&lt;<a class="el" href="#el_field_4" title="A signed integer value, unique for a field name by document (ex: date), used for sorting, queries, or retrieve (also available as a stored field).">alix:field</a> <b class="alix att">name</b>="<code class="val">year</code>" <b class="alix att">type</b>="<code class="val">int</code>" <b class="alix att">value</b>="<code class="val">2019</code>"/&gt;</div>
                  <div class="">
                    <span class="open">&lt;<a class="el" href="#el_field" title="&#10;Text to search with advanced lexical features (lemma, co-occurrences…).&#10;XML tags are allowed, well-formedness is not required, so HTML ready to display could be sent.&#10;Content is also available as a stored field for display, hilite of occurrences found, relevant excerpts.&#10;This type is quite heavy (positions, offsets, term vectors…).&#10;If you need a simple token search, prefer @type=&quot;meta&quot;.&#10;      ">alix:field</a> <b class="alix att">name</b>="<code class="val">text</code>" <b class="alix att">type</b>="<code class="val">text</code>"&gt;</span>
                    <span class="text">
      Le petit chat est mort.
    </span>
                    <span class="close">&lt;/<a class="el" href="#el_field" title="&#10;Text to search with advanced lexical features (lemma, co-occurrences…).&#10;XML tags are allowed, well-formedness is not required, so HTML ready to display could be sent.&#10;Content is also available as a stored field for display, hilite of occurrences found, relevant excerpts.&#10;This type is quite heavy (positions, offsets, term vectors…).&#10;If you need a simple token search, prefer @type=&quot;meta&quot;.&#10;      ">alix:field</a>&gt;</span>
                  </div>
                </dd>
                <dt class="close">&lt;/<a class="el" href="#docid1">alix:document</a>&gt;</dt>
              </dl>
              <dl class="xml ">
                <dt class="open"><a class="fold" tabindex="1">&lt;</a><a class="el" href="#docid2">alix:document</a> <b class="xml att">xml:id</b>="<code class="val">docid2</code>"&gt;</dt>
                <dd class="code">
                  <div class="">
                    <span class="open">&lt;<a class="el" href="#el_field" title="&#10;Text to search with advanced lexical features (lemma, co-occurrences…).&#10;XML tags are allowed, well-formedness is not required, so HTML ready to display could be sent.&#10;Content is also available as a stored field for display, hilite of occurrences found, relevant excerpts.&#10;This type is quite heavy (positions, offsets, term vectors…).&#10;If you need a simple token search, prefer @type=&quot;meta&quot;.&#10;      ">alix:field</a> <b class="alix att">name</b>="<code class="val">title</code>" <b class="alix att">type</b>="<code class="val">text</code>"&gt;</span>
                    <span class="text">Second document</span>
                    <span class="close">&lt;/<a class="el" href="#el_field" title="&#10;Text to search with advanced lexical features (lemma, co-occurrences…).&#10;XML tags are allowed, well-formedness is not required, so HTML ready to display could be sent.&#10;Content is also available as a stored field for display, hilite of occurrences found, relevant excerpts.&#10;This type is quite heavy (positions, offsets, term vectors…).&#10;If you need a simple token search, prefer @type=&quot;meta&quot;.&#10;      ">alix:field</a>&gt;</span>
                  </div>
                  <div class="open ">&lt;<a class="el" href="#el_field_4" title="A signed integer value, unique for a field name by document (ex: date), used for sorting, queries, or retrieve (also available as a stored field).">alix:field</a> <b class="alix att">name</b>="<code class="val">year</code>" <b class="alix att">type</b>="<code class="val">int</code>" <b class="alix att">value</b>="<code class="val">2019</code>"/&gt;</div>
                  <dl class="xml ">
                    <dt class="open"><a class="fold" tabindex="1">&lt;</a><a class="el" href="#el_field" title="&#10;Text to search with advanced lexical features (lemma, co-occurrences…).&#10;XML tags are allowed, well-formedness is not required, so HTML ready to display could be sent.&#10;Content is also available as a stored field for display, hilite of occurrences found, relevant excerpts.&#10;This type is quite heavy (positions, offsets, term vectors…).&#10;If you need a simple token search, prefer @type=&quot;meta&quot;.&#10;      ">alix:field</a> <b class="alix att">name</b>="<code class="val">text</code>" <b class="alix att">type</b>="<code class="val">text</code>"&gt;</dt>
                    <dd class="code">
                      <div class="xml_block ">
                        <span class="open"><a class="fold" tabindex="1">&lt;</a><a class="el" href="#el_p">p</a>&gt;</span>
                        <span class="xml_mix">
                          <span class="text">La </span>
                          <span class="">
                            <span class="open">&lt;<a class="el" href="#el_i">i</a>&gt;</span>
                            <span class="text">petite</span>
                            <span class="close">&lt;/<a class="el" href="#el_i">i</a>&gt;</span>
                          </span>
                          <span class="text"> chatte est morte.</span>
                        </span>
                        <span class="close">&lt;/<a class="el" href="#el_p">p</a>&gt;</span>
                      </div>
                    </dd>
                    <dt class="close">&lt;/<a class="el" href="#el_field" title="&#10;Text to search with advanced lexical features (lemma, co-occurrences…).&#10;XML tags are allowed, well-formedness is not required, so HTML ready to display could be sent.&#10;Content is also available as a stored field for display, hilite of occurrences found, relevant excerpts.&#10;This type is quite heavy (positions, offsets, term vectors…).&#10;If you need a simple token search, prefer @type=&quot;meta&quot;.&#10;      ">alix:field</a>&gt;</dt>
                  </dl>
                </dd>
                <dt class="close">&lt;/<a class="el" href="#docid2">alix:document</a>&gt;</dt>
              </dl>
              <dl class="xml ">
                <dt class="open"><a class="fold" tabindex="1">&lt;</a><a class="el" href="#bookid1">alix:book</a> <b class="xml att">xml:id</b>="<code class="val">bookid1</code>"&gt;</dt>
                <dd class="code">
                  <div class="">
                    <span class="open">&lt;<a class="el" href="#el_field" title="&#10;Text to search with advanced lexical features (lemma, co-occurrences…).&#10;XML tags are allowed, well-formedness is not required, so HTML ready to display could be sent.&#10;Content is also available as a stored field for display, hilite of occurrences found, relevant excerpts.&#10;This type is quite heavy (positions, offsets, term vectors…).&#10;If you need a simple token search, prefer @type=&quot;meta&quot;.&#10;      ">alix:field</a> <b class="alix att">name</b>="<code class="val">title</code>" <b class="alix att">type</b>="<code class="val">text</code>"&gt;</span>
                    <span class="text">Book title</span>
                    <span class="close">&lt;/<a class="el" href="#el_field" title="&#10;Text to search with advanced lexical features (lemma, co-occurrences…).&#10;XML tags are allowed, well-formedness is not required, so HTML ready to display could be sent.&#10;Content is also available as a stored field for display, hilite of occurrences found, relevant excerpts.&#10;This type is quite heavy (positions, offsets, term vectors…).&#10;If you need a simple token search, prefer @type=&quot;meta&quot;.&#10;      ">alix:field</a>&gt;</span>
                  </div>
                  <div class="">
                    <span class="open">&lt;<a class="el" href="#el_field_5" title="A term, unique for field name by document (ex: title), used as a classifier (also available for retrieve as a stored field).">alix:field</a> <b class="alix att">name</b>="<code class="val">author</code>" <b class="alix att">type</b>="<code class="val">facet</code>"&gt;</span>
                    <span class="text">Surname, Firstname</span>
                    <span class="close">&lt;/<a class="el" href="#el_field_5" title="A term, unique for field name by document (ex: title), used as a classifier (also available for retrieve as a stored field).">alix:field</a>&gt;</span>
                  </div>
                  <dl class="xml ">
                    <dt class="open"><a class="fold" tabindex="1">&lt;</a><a class="el" href="#el_field_3" title="Content to store (not for search nor sorting), maybe a text value in the @value attribute, or an xml content nested. &#10;        Stored values can be retrieved in search results (ex: url), or as an annex for a full document view (ex: table of contents).">alix:field</a> <b class="alix att">name</b>="<code class="val">toc</code>" <b class="alix att">type</b>="<code class="val">store</code>"&gt;</dt>
                    <dd class="code">
                      <dl class="xml ">
                        <dt class="open"><a class="fold" tabindex="1">&lt;</a><a class="el" href="#el_ul">ul</a>&gt;</dt>
                        <dd class="code">
                          <div class="">
                            <span class="open">&lt;<a class="el" href="#el_li">li</a>&gt;</span>
                            <span class="text">1) Chapter 1</span>
                            <span class="close">&lt;/<a class="el" href="#el_li">li</a>&gt;</span>
                          </div>
                          <div class="">
                            <span class="open">&lt;<a class="el" href="#el_li">li</a>&gt;</span>
                            <span class="text">2) Chapter 2</span>
                            <span class="close">&lt;/<a class="el" href="#el_li">li</a>&gt;</span>
                          </div>
                        </dd>
                        <dt class="close">&lt;/<a class="el" href="#el_ul">ul</a>&gt;</dt>
                      </dl>
                    </dd>
                    <dt class="close">&lt;/<a class="el" href="#el_field_3" title="Content to store (not for search nor sorting), maybe a text value in the @value attribute, or an xml content nested. &#10;        Stored values can be retrieved in search results (ex: url), or as an annex for a full document view (ex: table of contents).">alix:field</a>&gt;</dt>
                  </dl>
                  <div class="open ">&lt;<a class="el" href="#el_field_4" title="A signed integer value, unique for a field name by document (ex: date), used for sorting, queries, or retrieve (also available as a stored field).">alix:field</a> <b class="alix att">name</b>="<code class="val">year</code>" <b class="alix att">type</b>="<code class="val">int</code>" <b class="alix att">value</b>="<code class="val">2019</code>"/&gt;</div>
                  <dl class="xml ">
                    <dt class="open"><a class="fold" tabindex="1">&lt;</a><a class="el" href="#el_chapter">alix:chapter</a>&gt;</dt>
                    <dd class="code">
                      <div class="comment">&lt;!--<code> Useful metas for an application should be replicated, example facet  </code>--&gt;</div>
                      <div class="">
                        <span class="open">&lt;<a class="el" href="#el_field_5" title="A term, unique for field name by document (ex: title), used as a classifier (also available for retrieve as a stored field).">alix:field</a> <b class="alix att">name</b>="<code class="val">author</code>" <b class="alix att">type</b>="<code class="val">facet</code>"&gt;</span>
                        <span class="text">Surname, Firstname</span>
                        <span class="close">&lt;/<a class="el" href="#el_field_5" title="A term, unique for field name by document (ex: title), used as a classifier (also available for retrieve as a stored field).">alix:field</a>&gt;</span>
                      </div>
                      <dl class="xml ">
                        <dt class="open"><a class="fold" tabindex="1">&lt;</a><a class="el" href="#el_field">alix:field</a> <b class="alix att">name</b>="<code class="val">text</code>" <b class="alix att">type</b>="<code class="val">xml</code>"&gt;</dt>
                        <dd class="code">
                          <div class="">
                            <span class="open">&lt;<a class="el" href="#el_p">p</a>&gt;</span>
                            <span class="text">First chapter text</span>
                            <span class="close">&lt;/<a class="el" href="#el_p">p</a>&gt;</span>
                          </div>
                        </dd>
                        <dt class="close">&lt;/<a class="el" href="#el_field">alix:field</a>&gt;</dt>
                      </dl>
                    </dd>
                    <dt class="close">&lt;/<a class="el" href="#el_chapter">alix:chapter</a>&gt;</dt>
                  </dl>
                  <dl class="xml ">
                    <dt class="open"><a class="fold" tabindex="1">&lt;</a><a class="el" href="#el_chapter">alix:chapter</a>&gt;</dt>
                    <dd class="code">
                      <div class="">
                        <span class="open">&lt;<a class="el" href="#el_field_5" title="A term, unique for field name by document (ex: title), used as a classifier (also available for retrieve as a stored field).">alix:field</a> <b class="alix att">name</b>="<code class="val">author</code>" <b class="alix att">type</b>="<code class="val">facet</code>"&gt;</span>
                        <span class="text">Surname, Firstname</span>
                        <span class="close">&lt;/<a class="el" href="#el_field_5" title="A term, unique for field name by document (ex: title), used as a classifier (also available for retrieve as a stored field).">alix:field</a>&gt;</span>
                      </div>
                      <dl class="xml ">
                        <dt class="open"><a class="fold" tabindex="1">&lt;</a><a class="el" href="#el_field">alix:field</a> <b class="alix att">name</b>="<code class="val">text</code>" <b class="alix att">type</b>="<code class="val">xml</code>"&gt;</dt>
                        <dd class="code">
                          <div class="">
                            <span class="open">&lt;<a class="el" href="#el_p">p</a>&gt;</span>
                            <span class="text">Second chapter text</span>
                            <span class="close">&lt;/<a class="el" href="#el_p">p</a>&gt;</span>
                          </div>
                        </dd>
                        <dt class="close">&lt;/<a class="el" href="#el_field">alix:field</a>&gt;</dt>
                      </dl>
                    </dd>
                    <dt class="close">&lt;/<a class="el" href="#el_chapter">alix:chapter</a>&gt;</dt>
                  </dl>
                </dd>
                <dt class="close">&lt;/<a class="el" href="#bookid1">alix:book</a>&gt;</dt>
              </dl>
            </dd>
            <dt class="close">&lt;/<a class="el" href="#el_set">alix:set</a>&gt;</dt>
          </dl>
        </figure>
        <p>
As other lucene indexing platforms, Alix borrows some concepts from <a href="https://lucene.apache.org/solr/">Solr</a>,
but also, a less known but older open source product <a href="http://savannah.nongnu.org/projects/sdx/">SDX</a> (2001),
on which worked the creators of Alix.
    </p>
        <p>
Unlike Solr, ElasticSearch or others; Alix does not need a configuration file, closing 
the number, names and types of fields before indexing.
The declaration of fields is done at indexing time, allowing to add fields
when the documents need them.
The user of Alix library knows what he 
has indexed, so he knows what he will find.
    </p>
        <p>
Alix is XML friendly. Contents of fields could be a clean HTML ready to display in a web application,
all Alix analyzers and searching helpers know how to deal with tags and avoid to break them.
    </p>
        <p>
The proposed field types 
are designed to answer to a need, not to replicate Lucene API complexity.
Investigations have been done to offer the best of a Lucene for texts.
    </p>
        <p>
According to Lucene model, there are 3 levels of objects inside Alix.
    </p>
        <ul>
          <li>&lt;<a class="el" href="#el_field">field</a>&gt;, corresponding to a lucene 
        <a href="https://lucene.apache.org/core/8_2_0/core/org/apache/lucene/document/Field.html">Field</a>.
        A field has a name, a type, and a content.
        Alix defines a limited set of types, dedicated to text documents, content depends on type.
      </li>
          <li>&lt;<a class="el" href="#el_document">document</a>&gt;, a set of &lt;<a class="el" href="#el_field">field</a>&gt;s corresponding to a lucene 
        <a href="https://lucene.apache.org/core/8_2_0/core/org/apache/lucene/document/Document.html">Document</a></li>
          <li>&lt;<a class="el" href="#el_book">book</a>&gt;, a set of &lt;<a class="el" href="#el_chapter">chapter</a>&gt;s, 
        corresponding to an advance feature in lucene, allowing to index a group of Document objects,
        with a specefic one used as a cover
        <a href="https://lucene.apache.org/core/8_2_0/core/org/apache/lucene/index/IndexWriter.html#addDocuments-java.lang.Iterable-">IndexReader.addDocuments()</a>.
        A book is a useful unit in Alix for faceting results, or defining a corpus.
        For Lucene, a &lt;<a class="el" href="#el_chapter">chapter</a>&gt; is like a document. 
      </li>
        </ul>
      </div>
      <span class="documentation">The root element could be a single &lt;<a class="el" href="#el_document">document</a>&gt;, a &lt;<a class="el" href="#el_book">book</a>&gt;, or 
      a &lt;<a class="el" href="#el_set">set</a>&gt; (containing &lt;<a class="el" href="#el_document">document</a>&gt;s and &lt;<a class="el" href="#el_book">book</a>&gt;s).</span>
      <section class="element rng" id="el_set">
        <header class="element rng">&lt;<a>set</a>&gt; A set of &lt;<a class="el" href="#el_book">book</a>&gt;s or &lt;<a class="el" href="#el_document">document</a>&gt;s.</header>
        <table class="grammar">
          <tr>
            <th>Children</th>
            <td class="children"><div><b>B</b>. &lt;<a href="#el_book">book</a>&gt;  </div> <div><b>D</b>. &lt;<a href="#el_document">document</a>&gt;  </div> </td>
          </tr>
          <tr>
            <th>Model</th>
            <td class="model">
              <span class="compact choice">( <a href="#el_book">book</a> | <a href="#el_document">document</a> ) + </span>
            </td>
          </tr>
          <tr>
            <th>Parents</th>
            <td class="usage">start. </td>
          </tr>
        </table>
      </section>
      <section class="element rng" id="el_book">
        <header class="element rng">&lt;<a>book</a>&gt; A set of &lt;<a class="el" href="#el_chapter">chapter</a>&gt;s. A book can also contain &lt;<a class="el" href="#el_field">field</a>&gt;s (ex: title, author, date…).
      There is no inheritance of fields between books and chapters, to avoid non desired replication (ex: a table of contents of a full book).
      A String identifier, unique for the base, is required for a permanent access to a book.
      The identifier of chapters will be automatically calculated by Alix (identifier of book + a counter starting at 001).
      </header>
        <table class="grammar">
          <tr>
            <th>Attributes</th>
            <td>
              <table class="attributes">
                <tr>
                  <td class="name">@<a class="required" href="#att_xml-id">xml:id</a></td>
                  <td/>
                  <td>String identifier for the book.</td>
                </tr>
              </table>
            </td>
          </tr>
          <tr>
            <th>Children</th>
            <td class="children"><div><b>C</b>. &lt;<a href="#el_chapter">chapter</a>&gt;  </div> <div><b>F</b>. &lt;<a href="#el_field">field<small class="att"> type="text"</small></a>&gt; &lt;<a href="#el_field_2">field<small class="att"> type="meta"</small></a>&gt; &lt;<a href="#el_field_3">field<small class="att"> type="store"</small></a>&gt; &lt;<a href="#el_field_4">field<small class="att"> type="int"</small></a>&gt; &lt;<a href="#el_field_5">field<small class="att"> type="facet"</small></a>&gt; &lt;<a href="#el_field_6">field<small class="att"> type="facets"</small></a>&gt;  </div> </td>
          </tr>
          <tr>
            <th>Model</th>
            <td class="model">
              <span class="compact element">
                <span class="compact choice">( <span class="more"><a class="ref" href="#def_field">field</a> (<a class="toggle" onclick="o=this.parentNode; if(o.className=='more'){o.className='less'; this.innerHTML='▽';} else {o.className='more';this.innerHTML='►'}">►</a><span class="refin"><span class="compact choice">( <a href="#el_field">field<small class="att"> type="text"</small></a> | <a href="#el_field_2">field<small class="att"> type="meta"</small></a> | <a href="#el_field_3">field<small class="att"> type="store"</small></a> | <a href="#el_field_4">field<small class="att"> type="int"</small></a> | <a href="#el_field_5">field<small class="att"> type="facet"</small></a> | <a href="#el_field_6">field<small class="att"> type="facets"</small></a> )</span></span>)</span> | <a href="#el_chapter">chapter</a> ) + </span>
              </span>
            </td>
          </tr>
          <tr>
            <th>Parents</th>
            <td class="usage">start. <div><b>S</b>. &lt;<a href="#el_set">set</a>&gt;  </div> </td>
          </tr>
        </table>
      </section>
      <section class="element rng" id="el_chapter">
        <header class="element rng">&lt;<a>chapter</a>&gt; A set of &lt;<a class="el" href="#el_field">field</a>&gt;s, like a &lt;<a class="el" href="#el_document">document</a>&gt;, except it has to be inside a &lt;<a class="el" href="#el_book">book</a>&gt;.</header>
        <table class="grammar">
          <tr>
            <th>Children</th>
            <td class="children"><div><b>F</b>. &lt;<a href="#el_field">field<small class="att"> type="text"</small></a>&gt; &lt;<a href="#el_field_2">field<small class="att"> type="meta"</small></a>&gt; &lt;<a href="#el_field_3">field<small class="att"> type="store"</small></a>&gt; &lt;<a href="#el_field_4">field<small class="att"> type="int"</small></a>&gt; &lt;<a href="#el_field_5">field<small class="att"> type="facet"</small></a>&gt; &lt;<a href="#el_field_6">field<small class="att"> type="facets"</small></a>&gt;  </div> </td>
          </tr>
          <tr>
            <th>Model</th>
            <td class="model">
              <span class="more"><a class="ref" href="#def_field">field</a> (<a class="toggle" onclick="o=this.parentNode; if(o.className=='more'){o.className='less'; this.innerHTML='▽';} else {o.className='more';this.innerHTML='►'}">►</a><span class="refin"><span class="compact choice">( <a href="#el_field">field<small class="att"> type="text"</small></a> | <a href="#el_field_2">field<small class="att"> type="meta"</small></a> | <a href="#el_field_3">field<small class="att"> type="store"</small></a> | <a href="#el_field_4">field<small class="att"> type="int"</small></a> | <a href="#el_field_5">field<small class="att"> type="facet"</small></a> | <a href="#el_field_6">field<small class="att"> type="facets"</small></a> )</span></span>) + </span>
            </td>
          </tr>
          <tr>
            <th>Parents</th>
            <td class="usage"><div><b>B</b>. &lt;<a href="#el_book">book</a>&gt;  </div> </td>
          </tr>
        </table>
      </section>
      <section class="element rng" id="el_document">
        <header class="element rng">&lt;<a>document</a>&gt; A set of &lt;<a class="el" href="#el_field">field</a>&gt;s.</header>
        <table class="grammar">
          <tr>
            <th>Children</th>
            <td class="children"><div><b>F</b>. &lt;<a href="#el_field">field<small class="att"> type="text"</small></a>&gt; &lt;<a href="#el_field_2">field<small class="att"> type="meta"</small></a>&gt; &lt;<a href="#el_field_3">field<small class="att"> type="store"</small></a>&gt; &lt;<a href="#el_field_4">field<small class="att"> type="int"</small></a>&gt; &lt;<a href="#el_field_5">field<small class="att"> type="facet"</small></a>&gt; &lt;<a href="#el_field_6">field<small class="att"> type="facets"</small></a>&gt;  </div> </td>
          </tr>
          <tr>
            <th>Model</th>
            <td class="model">
              <span class="more"><a class="ref" href="#def_field">field</a> (<a class="toggle" onclick="o=this.parentNode; if(o.className=='more'){o.className='less'; this.innerHTML='▽';} else {o.className='more';this.innerHTML='►'}">►</a><span class="refin"><span class="compact choice">( <a href="#el_field">field<small class="att"> type="text"</small></a> | <a href="#el_field_2">field<small class="att"> type="meta"</small></a> | <a href="#el_field_3">field<small class="att"> type="store"</small></a> | <a href="#el_field_4">field<small class="att"> type="int"</small></a> | <a href="#el_field_5">field<small class="att"> type="facet"</small></a> | <a href="#el_field_6">field<small class="att"> type="facets"</small></a> )</span></span>) + </span>
            </td>
          </tr>
          <tr>
            <th>Parents</th>
            <td class="usage">start. <div><b>S</b>. &lt;<a href="#el_set">set</a>&gt;  </div> </td>
          </tr>
        </table>
      </section>
      <section class="define rng" id="def_field">
        <header class="define rng">
          <b>field() </b>
        </header>
        <table class="grammar">
          <tr>
            <th>Content</th>
            <td>
              <span class="compact choice">( <a href="#el_field">field<small class="att"> type="text"</small></a> | <a href="#el_field_2">field<small class="att"> type="meta"</small></a> | <a href="#el_field_3">field<small class="att"> type="store"</small></a> | <a href="#el_field_4">field<small class="att"> type="int"</small></a> | <a href="#el_field_5">field<small class="att"> type="facet"</small></a> | <a href="#el_field_6">field<small class="att"> type="facets"</small></a> )</span>
            </td>
          </tr>
          <tr>
            <th>Usage</th>
            <td><div><b>B</b>. &lt;<a href="#el_book">book</a>&gt;  </div> <div><b>C</b>. &lt;<a href="#el_chapter">chapter</a>&gt;  </div> <div><b>D</b>. &lt;<a href="#el_document">document</a>&gt;  </div> </td>
          </tr>
        </table>
      </section>
      <section class="element rng" id="el_field">
        <header class="element rng">&lt;<a>field<small class="att"> type="text"</small></a>&gt; 
Text to search with advanced lexical features (lemma, co-occurrences…).
XML tags are allowed, well-formedness is not required, so HTML ready to display could be sent.
Content is also available as a stored field for display, hilite of occurrences found, relevant excerpts.
This type is quite heavy (positions, offsets, term vectors…).
If you need a simple token search, prefer @type="meta".
      </header>
        <table class="grammar">
          <tr>
            <th>Attributes</th>
            <td>
              <table class="attributes">
                <tr>
                  <td class="name">@<a class="required" href="#att_name">name</a></td>
                  <td/>
                  <td><em class="data" title="">{Name}</em><br/>Field name is required.</td>
                </tr>
                <tr>
                  <td class="name">@<a class="required" href="#att_type">type="text"</a></td>
                  <td/>
                  <td>
                    <span class="value">text</span>
                    <br/>
                  </td>
                </tr>
              </table>
            </td>
          </tr>
          <tr>
            <th>Children</th>
            <td class="children"/>
          </tr>
          <tr>
            <th>Model</th>
            <td class="model">
              <span class="compact element"> <span class="compact choice">( <i>{text}</i> | <a href="#el_">*</a> ) + </span></span>
            </td>
          </tr>
          <tr>
            <th>Parents</th>
            <td class="usage"><div><b>B</b>. &lt;<a href="#el_book">book</a>&gt;  </div> <div><b>C</b>. &lt;<a href="#el_chapter">chapter</a>&gt;  </div> <div><b>D</b>. &lt;<a href="#el_document">document</a>&gt;  </div> </td>
          </tr>
        </table>
      </section>
      <section class="element rng" id="el_field_2">
        <header class="element rng">&lt;<a>field<small class="att"> type="meta"</small></a>&gt; 
Some text (or xml) to search as raw tokens without linguistic features. Is especially useful to search 
in bibliographic records by token.
      </header>
        <table class="grammar">
          <tr>
            <th>Attributes</th>
            <td>
              <table class="attributes">
                <tr>
                  <td class="name">@<a class="required" href="#att_name">name</a></td>
                  <td/>
                  <td><em class="data" title="">{Name}</em><br/>Field name is required.</td>
                </tr>
                <tr>
                  <td class="name">@<a class="required" href="#att_type">type="meta"</a></td>
                  <td/>
                  <td>
                    <span class="value">meta</span>
                    <br/>
                  </td>
                </tr>
                <tr>
                  <td class="name">@<a href="#att_value">value</a></td>
                  <td>?</td>
                  <td/>
                </tr>
              </table>
            </td>
          </tr>
          <tr>
            <th>Children</th>
            <td class="children"/>
          </tr>
          <tr>
            <th>Model</th>
            <td class="model">
              <span class="compact element">
                <span class="compact choice"> ( <span class="compact choice">( <i>{text}</i> | <a href="#el_">*</a> ) + </span> )</span>
              </span>
            </td>
          </tr>
          <tr>
            <th>Parents</th>
            <td class="usage"><div><b>B</b>. &lt;<a href="#el_book">book</a>&gt;  </div> <div><b>C</b>. &lt;<a href="#el_chapter">chapter</a>&gt;  </div> <div><b>D</b>. &lt;<a href="#el_document">document</a>&gt;  </div> </td>
          </tr>
        </table>
      </section>
      <section class="element rng" id="el_field_3">
        <header class="element rng">&lt;<a>field<small class="att"> type="store"</small></a>&gt; Content to store (not for search nor sorting), maybe a text value in the @value attribute, or an xml content nested. 
        Stored values can be retrieved in search results (ex: url), or as an annex for a full document view (ex: table of contents).</header>
        <table class="grammar">
          <tr>
            <th>Attributes</th>
            <td>
              <table class="attributes">
                <tr>
                  <td class="name">@<a class="required" href="#att_name">name</a></td>
                  <td/>
                  <td><em class="data" title="">{Name}</em><br/>Field name is required.</td>
                </tr>
                <tr>
                  <td class="name">@<a class="required" href="#att_type">type="store"</a></td>
                  <td/>
                  <td>
                    <span class="value">store</span>
                    <br/>
                  </td>
                </tr>
                <tr>
                  <td class="name">@<a href="#att_value">value</a></td>
                  <td>?</td>
                  <td/>
                </tr>
              </table>
            </td>
          </tr>
          <tr>
            <th>Children</th>
            <td class="children"/>
          </tr>
          <tr>
            <th>Model</th>
            <td class="model">
              <span class="compact element">
                <span class="compact choice"> ( <span class="compact choice">( <i>{text}</i> | <a href="#el_">*</a> ) + </span> )</span>
              </span>
            </td>
          </tr>
          <tr>
            <th>Parents</th>
            <td class="usage"><div><b>B</b>. &lt;<a href="#el_book">book</a>&gt;  </div> <div><b>C</b>. &lt;<a href="#el_chapter">chapter</a>&gt;  </div> <div><b>D</b>. &lt;<a href="#el_document">document</a>&gt;  </div> </td>
          </tr>
        </table>
      </section>
      <section class="element rng" id="el_field_4">
        <header class="element rng">&lt;<a>field<small class="att"> type="int"</small></a>&gt; A signed integer value, unique for a field name by document (ex: date), used for sorting, queries, or retrieve (also available as a stored field).</header>
        <table class="grammar">
          <tr>
            <th>Attributes</th>
            <td>
              <table class="attributes">
                <tr>
                  <td class="name">@<a class="required" href="#att_name">name</a></td>
                  <td/>
                  <td><em class="data" title="">{Name}</em><br/>Field name is required.</td>
                </tr>
                <tr>
                  <td class="name">@<a class="required" href="#att_type">type="int"</a></td>
                  <td/>
                  <td>
                    <span class="value">int</span>
                    <br/>
                  </td>
                </tr>
                <tr>
                  <td class="name">@<a class="required" href="#att_value">value</a></td>
                  <td/>
                  <td>
                    <em class="data" title="">{int}</em>
                    <br/>
                  </td>
                </tr>
              </table>
            </td>
          </tr>
          <tr>
            <th>Model</th>
            <td class="model"/>
          </tr>
          <tr>
            <th>Parents</th>
            <td class="usage"><div><b>B</b>. &lt;<a href="#el_book">book</a>&gt;  </div> <div><b>C</b>. &lt;<a href="#el_chapter">chapter</a>&gt;  </div> <div><b>D</b>. &lt;<a href="#el_document">document</a>&gt;  </div> </td>
          </tr>
        </table>
      </section>
      <section class="element rng" id="el_field_5">
        <header class="element rng">&lt;<a>field<small class="att"> type="facet"</small></a>&gt; A term, unique for field name by document (ex: title), used as a classifier (also available for retrieve as a stored field).</header>
        <table class="grammar">
          <tr>
            <th>Attributes</th>
            <td>
              <table class="attributes">
                <tr>
                  <td class="name">@<a class="required" href="#att_name">name</a></td>
                  <td/>
                  <td><em class="data" title="">{Name}</em><br/>Field name is required.</td>
                </tr>
                <tr>
                  <td class="name">@<a class="required" href="#att_type">type="facet"</a></td>
                  <td/>
                  <td>
                    <span class="value">facet</span>
                    <br/>
                  </td>
                </tr>
                <tr>
                  <td class="name">@<a class="required" href="#att_value">value</a></td>
                  <td/>
                  <td/>
                </tr>
              </table>
            </td>
          </tr>
          <tr>
            <th>Model</th>
            <td class="model"/>
          </tr>
          <tr>
            <th>Parents</th>
            <td class="usage"><div><b>B</b>. &lt;<a href="#el_book">book</a>&gt;  </div> <div><b>C</b>. &lt;<a href="#el_chapter">chapter</a>&gt;  </div> <div><b>D</b>. &lt;<a href="#el_document">document</a>&gt;  </div> </td>
          </tr>
        </table>
      </section>
      <section class="element rng" id="el_field_6">
        <header class="element rng">&lt;<a>field<small class="att"> type="facets"</small></a>&gt; Set of terms by document (ex: author) used as a classifier for the collection (also available for retrieve as a stored field).</header>
        <table class="grammar">
          <tr>
            <th>Attributes</th>
            <td>
              <table class="attributes">
                <tr>
                  <td class="name">@<a class="required" href="#att_name">name</a></td>
                  <td/>
                  <td><em class="data" title="">{Name}</em><br/>Field name is required.</td>
                </tr>
                <tr>
                  <td class="name">@<a class="required" href="#att_type">type="facets"</a></td>
                  <td/>
                  <td>
                    <span class="value">facets</span>
                    <br/>
                  </td>
                </tr>
                <tr>
                  <td class="name">@<a class="required" href="#att_value">value</a></td>
                  <td/>
                  <td/>
                </tr>
              </table>
            </td>
          </tr>
          <tr>
            <th>Model</th>
            <td class="model"/>
          </tr>
          <tr>
            <th>Parents</th>
            <td class="usage"><div><b>B</b>. &lt;<a href="#el_book">book</a>&gt;  </div> <div><b>C</b>. &lt;<a href="#el_chapter">chapter</a>&gt;  </div> <div><b>D</b>. &lt;<a href="#el_document">document</a>&gt;  </div> </td>
          </tr>
        </table>
      </section>
      <section class="attribute rng" id="att_name">
        <header class="attribute rng">@<b>name</b> Field name is required.</header>
        <table class="grammar">
          <tr>
            <th>Value</th>
            <td>
              <em class="data">{Name}</em>
            </td>
          </tr>
          <tr>
            <th>Parents</th>
            <td class="usage"><div><b>F</b>. &lt;<a href="#el_field">field<small class="att"> type="text"</small></a>&gt; &lt;<a href="#el_field_2">field<small class="att"> type="meta"</small></a>&gt; &lt;<a href="#el_field_3">field<small class="att"> type="store"</small></a>&gt; &lt;<a href="#el_field_4">field<small class="att"> type="int"</small></a>&gt; &lt;<a href="#el_field_5">field<small class="att"> type="facet"</small></a>&gt; &lt;<a href="#el_field_6">field<small class="att"> type="facets"</small></a>&gt;  </div> </td>
          </tr>
        </table>
      </section>
      <section class="define rng" id="def_xml">
        <header class="define rng">
          <b>xml() </b>
        </header>
        <table class="grammar">
          <tr>
            <th>Content</th>
            <td>
              <span class="compact choice">( <i>{text}</i> | <a href="#el_">*</a> ) + </span>
            </td>
          </tr>
          <tr>
            <th>Usage</th>
            <td><div><b>F</b>. &lt;<a href="#el_field">field<small class="att"> type="text"</small></a>&gt; &lt;<a href="#el_field_2">field<small class="att"> type="meta"</small></a>&gt; &lt;<a href="#el_field_3">field<small class="att"> type="store"</small></a>&gt;  </div> </td>
          </tr>
        </table>
      </section>
      <section class="element rng" id="el_">
        <header class="element rng">&lt;<a>*</a>&gt; </header>
        <table class="grammar">
          <tr>
            <th>Attributes</th>
            <td>
              <table class="attributes">
                <tr>
                  <td class="name">@<a href="#att_"/></td>
                  <td>?</td>
                  <td/>
                </tr>
              </table>
            </td>
          </tr>
          <tr>
            <th>Children</th>
            <td class="children"/>
          </tr>
          <tr>
            <th>Model</th>
            <td class="model">
              <span class="compact element">
                <span class="compact choice"> ( <i>{text}</i> | <a href="#el_">*</a> ) * </span>
              </span>
            </td>
          </tr>
          <tr>
            <th>Parents</th>
            <td class="usage"><div><b>F</b>. &lt;<a href="#el_field">field<small class="att"> type="text"</small></a>&gt; &lt;<a href="#el_field_2">field<small class="att"> type="meta"</small></a>&gt; &lt;<a href="#el_field_3">field<small class="att"> type="store"</small></a>&gt;  </div> </td>
          </tr>
        </table>
      </section>
    </article>
    <script>
var els = document.getElementsByTagName('a');
for(var i = 0, len = els.length; i < len; i++) {
  if (els[i].title) continue;
  els[i].onmouseover = function () {
    var t0 = performance.now();
    if (this.title) return true;
    if (!this.hash) return true;
    var id = this.hash.substring(1);
    if (!id) return true;
    var div = document.getElementById(id);
    if (!div) return true;
    var header = div.getElementsByTagName('header');
    if (header.length == 0) return true;
    this.title = header[0].textContent;
    return true;
  }
}      
    </script>
  </body>
</html>
