package alix.util;

import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.IOException;
import java.io.PrintStream;
import java.io.PrintWriter;
import java.io.StringWriter;
import java.io.Writer;
import java.nio.charset.Charset;
import java.nio.file.Files;
import java.nio.file.Path;
import java.util.ArrayList;
import java.util.Collections;
import java.util.HashMap;
import java.util.List;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.concurrent.atomic.AtomicLong;
import java.util.concurrent.locks.ReentrantLock;

/**
 * A specialized table for a dictionary of terms, with an int code, an int
 * counter, and an int tag. Conceived for performances, for linguistic usage,
 * but the object do not requires lexical informations. The int code is a way to
 * optimize complex pattern storage (ex: wordgrams). Access possible by a String
 * term (internal HashMap), or by an int code (internal array, for optimized
 * vector). There are useful methods to get term list in inverse frequency
 * order.
 * 
 * Each term added will create an entry or increment a counter if already
 * exists. Int code, generated by an internal autoincrement pointer. It’s a grow
 * only object, entries can’t be removed. There’s no method to put a term with a
 * free code, terms are never replaced and keep their code. Codes are kept
 * consistent during all life of Object.
 * 
 * 
 * — TODO implement saving on SQL backend — TODO dictionary merges
 * 
 * code->String->[code, counter, tag], access by code need another jump to get
 * the tag.
 * 
 * A String can keep an int tag, set at creation of the entry but is not
 * modified. This could be used to filter dictionary outputs (ex: just
 * substantives, only nouns) with no more lexical informations about the Strings
 * stored. But be careful, this tag is not used as a component for the key. This
 * dictionary do not distinguish homographs by gramcat (same String key,
 * different int tag). The experience shows that a tag is usually not sufficient
 * to distinguish linguistic homography (ex: suis<VERB,être>,
 * suis<VERB,suivre>.). Better approach is to forge String keys outside from
 * this dictionary (ex: suis,être ; suis,suivre)
 * 
 * @author glorieux-f
 *
 */
public class DicFreq
{
  private ReentrantLock lock = new ReentrantLock();
  /**
   * HashMap to find by String. String is the best object for key (most common,
   * not mutable). A custom object (like Term) will not match against String. The
   * int array contains an int key and a count
   */
  private HashMap<String, Entry> byTerm = new HashMap<String, Entry>();
  /** List of terms, kept in index order, to get a term by int code */
  private Entry[] byCode = new Entry[32];
  /**
   * Pointer in the array of terms, only growing when terms are added, used as
   * code
   */
  private int pointer;
  /** Count of all occurrences for this dico */
  private AtomicLong occs = new AtomicLong();
  /** The separator for CSV export and import */
  private static char SEP = ';';

  /**
   * A term record in the dictionary, obtained by String or by code
   * 
   * @author glorieux-f
   */
  public class Entry implements Comparable<Entry>
  {
    /** The String form of Term */
    private final String label;
    /** Internal code for the term */
    private final int code;
    /** A tag ex gram cat */
    private final int tag;
    /** A counter */
    private AtomicInteger count = new AtomicInteger();
    /** A secondary counter (for comparisons) */
    private AtomicInteger count2 = new AtomicInteger();

    private Entry(int code, String label, int tag) {
      this.code = code;
      this.label = label;
      this.tag = tag;
    }

    public String label()
    {
      return label;
    }

    public int code()
    {
      return code;
    }

    public int tag()
    {
      return tag;
    }

    public int count()
    {
      return count.get();
    }

    public int count2()
    {
      return count2.get();
    }

    /**
     * Is used for debug, is not a save method
     */
    @Override
    public String toString()
    {
      StringBuffer sb = new StringBuffer();
      sb.append(label).append(SEP).append(count).append(SEP).append(code).append(SEP).append(tag).append(SEP)
          .append(count2);
      return sb.toString();
    }

    @Override
    /**
     * Default comparator for term informations,
     */
    public int compareTo(Entry o)
    {
      
      return (o.count.get() + o.count2.get()) - (count.get() + count2.get());
    }
  }

  /**
   * Constructor
   */
  public DicFreq()
  {
  }

  /**
   * Open a dictionary with a list of terms
   * 
   * @param terms
   */
  public DicFreq(final String[] terms)
  {
    for (String term : terms)
      add(term, 0, 1, 0);
  }

  /**
   * For object reuse, and not too much memory reallocation, reset counters
   * (objects are kept)
   */
  synchronized public void reset()
  {
    occs.set(0);
    pointer = 0;
    byTerm.clear();
  }

  /**
   * Get a term by code
   * 
   * @param index
   * @return the term
   */
  public String label(final int code)
  {
    if (code < 1)
      return null;
    if (code > pointer)
      return null;
    return byCode[code].label;
  }

  /**
   * Get the code of a term, -1 if not found
   * 
   * @param term
   * @return the key
   */
  public int code(Term term)
  {
    Entry vals = byTerm.get(term);
    if (vals == null)
      return -1;
    return vals.code;
  }

  /**
   * Get the code of a term, -1 if not found
   * 
   * @param term
   * @return the key
   */
  public int code(String term)
  {
    Entry line = byTerm.get(term);
    if (line == null)
      return -1;
    return line.code;
  }

  /**
   * Get the tag of a term, 0 if not found
   * 
   * @param term
   * @return the key
   */
  public int tag(Term term)
  {
    Entry line = byTerm.get(term);
    if (line == null)
      return 0;
    return line.tag;
  }

  /**
   * Get the code of a term, 0 if not found
   * 
   * @param term
   * @return the key
   */
  public int tag(String term)
  {
    Entry line = byTerm.get(term);
    if (line == null)
      return 0;
    return line.tag;
  }

  /**
   * Get the tag of a term by code, 0 if not found
   * 
   * @param code
   *          a term index
   * @return the state of counter after increments
   */
  public int tag(int code)
  {
    Entry line = byCode[code];
    if (line == null)
      return 0;
    return line.tag;
  }

  /**
   * Get the count for a term by String, -1 if not found
   * 
   * @param term
   * @return the count of occurrences
   */
  public int count(String term)
  {
    Entry line = byTerm.get(term);
    if (line == null)
      return -1;
    return line.count.get();
  }

  /**
   * Get the count for a term by Term (a mutable String), -1 if not found
   * 
   * @param term
   * @return the count of occurrences
   */
  public int count(Term term)
  {
    Entry line = byTerm.get(term);
    if (line == null)
      return -1;
    return line.count.get();
  }

  /**
   * Get the count of a term by code, -1 if not found
   * 
   * @param code
   *          a term index
   * @return the state of counter after increments
   */
  public int count(int code)
  {
    if (code < 1)
      return -1;
    if (code > pointer)
      return -1;
    return byCode[code].count.get();
  }


  /**
   * Increment a term, set its count at 1, or increment if exists
   * 
   * @param term
   *          a word
   * @return the code of term
   */
  public int inc(final String term)
  {
    Entry entry = byTerm.get(term);
    if (entry == null)
      entry =  entry(term, 0);
    entry.count.incrementAndGet();
    occs.incrementAndGet();
    return entry.code;
  }

  /**
   * Increment a term, or set its counter to 1 if not exists.
   * 
   * @param term
   *          a word
   * @return the code of term
   */
  public int inc(final Term term)
  {
    return inc(term, 0);
  }

  /**
   * Increment an alternate counter for a term, or set it to 1 if not exists.
   * 
   * @param term
   *          a word
   * @return the code of term
   */
  public int inc2(final String term)
  {
    return add(term, 0, 0, 1);
  }

  /**
   * Increment an alternate counter for a term, or set it to 1 if not exists.
   * 
   * @param term
   *          a word
   * @return the code of term
   */
  public int inc2(final Term term)
  {
    return add(term, 0, 0, 1);
  }

  /**
   * Increment a term with a tag, or set its counter to 1 if not exists.
   * 
   * @param term
   *          a word
   * @param tag
   *          a category code
   * @return the code of term
   */
  public int inc(final String term, final int tag)
  {
    Entry entry = byTerm.get(term);
    if (entry == null)
      entry =  entry(term, tag);
    entry.count.incrementAndGet();
    occs.incrementAndGet();
    return entry.code;
  }

  /**
   * Increment a term with a tag, or set its counter to 1 if not exists.
   * 
   * @param term
   *          a word
   * @param tag
   *          a category code
   * @return the code of term
   */
  public int inc(final Term term, final int tag)
  {
    Entry entry = byTerm.get(term);
    if (entry == null) entry = entry(term.toString(), tag);
    entry.count.incrementAndGet();
    occs.incrementAndGet();
    return entry.code;
  }

  /**
   * Increment an alternate counter for a term with a tag, or set it to 1 if not exists.
   * 
   * @param term
   *          a word
   * @return the code of term
   */
  public int inc2(final String term, final int tag)
  {
    return add(term, tag, 0, 1);
  }

  /**
   * Increment an alternate counter for a term, or set it to 1 if not exists.
   * 
   * @param term
   *          a word
   * @return the code of term
   */
  public int inc2(final Term term, final int tag)
  {
    return add(term, tag, 0, 1);
  }

  /**
   * Add delta to a term, or set it to delta if not exists.
   * 
   * @param term
   *          a word
   * @param delta
   *          add to counter
   * @return the code of term
   */
  public int add(final String term, final int delta)
  {
    return add(term, 0, delta, 0);
  }

  /**
   * Add delta to a term, or set it to delta if not exists.
   * 
   * @param term
   *          a word
   * @param delta
   *          add to counter
   * @return the code of term
   */
  public int add(final Term term, final int delta)
  {
    return add(term, 0, delta, 0);
  }

  /**
   * Add delta to a term with a tag, or set it to delta if not exists.
   * 
   * @param term
   *          a word
   * @param delta
   *          add to counter
   * @return the code of term
   */
  public int add(final String term, final int tag, final int delta)
  {
    return add(term, tag, delta, 0);
  }

  /**
   * Add delta to a term with a tag, or set it to delta if not exists.
   * 
   * @param term
   *          a word
   * @param delta
   *          add to counter
   * @return the code of term
   */
  public int add(final Term term, final int tag, final int delta)
  {
    return add(term, tag, delta, 0);
  }

  /**
   * Add delta1 and delta2 to the 2 counters of a term,
   * if not exists create it with a tag and set counters.
   * 
   * @param term
   * @param count1
   *          for first counter
   * @param count2
   *          for second counter
   * @return code (old or new)
   */
  public int add(final String term, final int tag, final int delta1, final int delta2)
  {
    Entry entry = entry(term, tag);
    entry.count.addAndGet(delta1);
    entry.count2.addAndGet(delta2);
    occs.addAndGet(delta1);
    occs.addAndGet(delta2);
    return entry.code;
  }

  /**
   * Add delta1 and delta2 to the 2 counters of a term,
   * if not exists create it with a tag and set counters amounts.
   * 
   * @param term
   * @param count1
   *          first count
   * @param count2
   *          second counter
   * @return code (old or new)
   */
  public int add(final Term term, final int tag, final int delta1, final int delta2)
  {
    Entry entry = byTerm.get(term);
    if (entry == null) {
      entry = entry(term.toString(), tag);
    }
    entry.count.addAndGet(delta1);
    entry.count2.addAndGet(delta2);
    occs.addAndGet(delta1);
    occs.addAndGet(delta2);
    return entry.code;
  }


  /**
   * Put a full entry, synchronized method to keep conssitency.
   * 
   * @param term
   * @param tag
   * @param count
   * @param count2
   * @return
   */
  public int put(final Term term, final int tag, final int count, final int count2)
  {
    Entry entry = byTerm.get(term);
    if (entry == null) {
      entry = entry(term.toString(), tag);
    }
    return put(entry, count, count2);
  }

  
  /**
   * Put a full entry.
   * 
   * @param term
   * @param tag
   * @param count
   * @param count2
   * @return
   */
  public int put(final String term, final int tag, final int count, final int count2)
  {
    Entry entry = entry(term, tag);
    return put(entry, count, count2);
  }

  public int put(Entry entry, final int count, final int count2)
  {
    synchronized (entry) {
      occs.set(occs.get() - entry.count.get() - entry.count2.get() + count + count2);
      entry.count.set(count);
      entry.count2.set(count2);
    }
    return entry.code;
  }

  /**
   * Create a term if not exists, but do not modify counts.
   * 
   * @param term
   * @return index code
   */
  public int put(final String term)
  {
    return put(term, 0, 0, 0);
  }

  /**
   * Create a term if not exists, but do not modify counts
   * 
   * @param term
   * @return index code
   */
  public int put(final Term term)
  {
    return put(term, 0, 0, 0);
  }

  public int put(final Term term, final int tag)
  {
    return put(term, tag, 0, 0);
  }

  public int put(final String term, final int tag)
  {
    return put(term, tag, 0, 0);
  }
  public int put(final Term term, final int tag, final int count)
  {
    return put(term, tag, count, 0);
  }

  public int put(final String term, final int tag, final int count)
  {
    return put(term, tag, count, 0);
  }

  /**
   * Create a term in the different data structures.
   * Critic fro multiThreading.
   * 
   * @param term
   * @param tag
   *          An int tag for output filtering
   * @param count
   *          initial value for counter
   * @param count2
   *          initial value for secondary counter
   * @return
   */
  private synchronized Entry entry(final String term, final int tag)
  {
    // possible queue, multiple call and entry creation is not finished
    Entry entry = byTerm.get(term);
    if (entry != null) {
      return entry;
    }
    pointer++;
    // index is too short, extends it (not a big perf pb)
    if (pointer >= byCode.length) {
      final int oldLength = byCode.length;
      final Entry[] oldData = byCode;
      byCode = new Entry[Calcul.nextSquare(oldLength)];
      System.arraycopy(oldData, 0, byCode, 0, oldLength);
    }
    entry = new Entry(pointer, term, tag);
    // put the same line object by reference in HashMap and Array
    byCode[pointer] = entry;
    byTerm.put(term, entry);
    return entry;
  }

  /**
   * Size of the dictionary
   */
  public int size()
  {
    return pointer;
  }

  /**
   * Sum of all counts
   */
  public long occs()
  {
    return occs.get();
  }

  /**
   * Increment occurrences count with not stored terms (useful for filtered
   * dictionary)
   */
  public DicFreq inc()
  {
    occs.incrementAndGet();
    return this;
  }

  /**
   * Increment occurrences count with not stored terms (useful for filtered
   * dictionary)
   */
  public DicFreq add(int delta)
  {
    occs.addAndGet(delta);
    return this;
  }

  /**
   * Return an iterable object to get freqlist
   * 
   * @return
   */
  public List<Entry> byCount()
  {
    List<Entry> list = new ArrayList<Entry>(byTerm.values()); // will copy entries (?)
    Collections.sort(list);
    return list;
  }

  public Entry[] entries()
  {
    return byCode;
  }

  /**
   * To save the dictionary, with some index consistency but… will not works on
   * merge
   * 
   * @param file
   * @throws NumberFormatException
   * @throws IOException
   */
  public void csv(Path path) throws IOException
  {
    BufferedWriter writer = Files.newBufferedWriter(path, Charset.forName("UTF-8"));
    csv(writer);
  }

  /**
   * Send a CSV version of the dictionary
   * 
   * @return a CSV string
   */
  public String csv()
  {
    return csv(-1);
  }

  /**
   * Send a CSV version of the dictionary
   * 
   * @return a CSV string
   * @throws IOException 
   */
  public String csv(int limit)
  {
    StringWriter writer = new StringWriter();
    try {
      csv(writer, limit);
    }
    catch(Exception e) {
      e.printStackTrace(System.out);
    }
    return writer.toString();
  }

  /**
   * Send a CSV version of the dictionary
   * 
   * @return a CSV string
   */
  /*
   * public String csv( int size, Set<String> stoplist ) { String ret = null; try
   * { ret = csv( new StringWriter(), size, stoplist ).toString(); } catch
   * (IOException e) { e.printStackTrace(); } return ret; }
   */

  /**
   * Give a csv view of all dictionary
   * 
   * @throws IOException
   */
  public Writer csv(Writer writer) throws IOException
  {
    return csv(writer, -1);
  }

  public void csv(PrintStream stream, int limit) throws IOException
  {
    Writer writer = new PrintWriter(stream);
    csv(writer, limit);
  }

  /**
   * Give a csv view of all dictionary TODO a top filter
   * 
   * @throws IOException
   */
  public Writer csv(Writer writer, int limit) throws IOException
  {
    // TODO total occs
    writer.write("(" + occs + ")" + SEP + "COUNT" + SEP + "CODE" + SEP + "TAG" + SEP + "COUNT2" + SEP + "PPM" + "\n");
    try {
      for (Entry entry : byCount()) {
        if (limit-- == 0)
          break;
        writer.write(entry.toString());
        writer.write(SEP);
        writer.write("" + (double) Math.round(100000000.0 * entry.count.get() / occs.get()) / 100);
        writer.write("\n");
      }
    }
    finally {
      writer.flush();
    }
    return writer;
  }

  /**
   * DEPRECATED, use a CompDic nstead. Give a csv view of all dictionary
   * 
   * @throws IOException
   */
  /*
   * public Writer csvcomp( Writer writer, int limit, Set<Term> stoplist ) throws
   * IOException { String[] byCount = byCount(); int length = byCount.length; int
   * count1; int count2; try { for (int i = 0; i < length; i++) { if (stoplist !=
   * null && stoplist.contains( byCount[i] )) continue; if (limit-- == 0) break;
   * Terminfos values = byTerm.get( byCount[i] ); count1 = values.count; count2 =
   * values.count2; writer.write( byCount[i] +"\t"+ count1 +"\t"+ count2 +"\t"+
   * (count1+count2) +"\t"+NumberFormat.getInstance().format( 1.0*count1 /
   * (count1+count2) ) // +"\t"+index(byCount[i]) +"\n" ); } } finally {
   * writer.close(); } return writer; }
   */

  /**
   * Is used for debug, is not a save method
   */
  @Override
  public String toString()
  {
    StringWriter writer = new StringWriter();
    try {
      csv(writer, 100);
    }
    catch (IOException e) {
      e.printStackTrace();
    }
    return writer.toString();
  }

  /**
   * Load a freqlist from csv TODO test it
   * 
   * @param file
   * @throws IOException
   * @throws NumberFormatException
   */
  public void load(Path path) throws IOException
  {
    BufferedReader reader = Files.newBufferedReader(path, Charset.forName("UTF-8"));
    String line = null;
    int value;
    try {
      // pass first line
      line = reader.readLine();
      while ((line = reader.readLine()) != null) {
        if (line.contains("\t")) {
          String[] strings = line.split("\t");
          try {
            value = Integer.parseInt(strings[1]);
          }
          catch (NumberFormatException e) {
            continue;
          }
          add(strings[0].trim(), value);
        }
        else {
          inc(line.trim());
        }
      }
    }
    finally {
      reader.close();
    }
  }

  
  /**
   * Testing
   * 
   * @throws IOException
   */
  public static void main(String[] args) throws IOException
  {
    // test synchonisation
    /*
    BufferedReader buf = new BufferedReader(
        new InputStreamReader(DicFreq.class.getResourceAsStream("/alix/fr/dic/loc.csv"), StandardCharsets.UTF_8));
    String l;
    DicFreq dic = new DicFreq();
    while ((l = buf.readLine()) != null) {
      if (l.isEmpty())
        continue;
      for (String s : l.split("[ ;]+")) {
        dic.inc(s);
      }
    }
    dic.csv(new PrintWriter(System.out));
    */
  }
}
