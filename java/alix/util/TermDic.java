package alix.util;

import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.IOException;
import java.io.StringWriter;
import java.io.Writer;
import java.nio.charset.Charset;
import java.nio.file.Files;
import java.nio.file.Path;
import java.text.NumberFormat;
import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Set;

/**
 * A specialized table for a dictionary of terms, with an int code, an int counter, and an int tag. 
 * Conceived for performances, for linguistic usage, but the object do not requires lexical informations.
 * The int code is a way to optimize complex pattern storage (ex: wordgrams).
 * Access can be by a String tern (internal HashMap), by an int code (internal array, for optimized vector).
 * There are useful methods to get term list in inverse frequency order.
 * 
 * Each term added will create an entry or increment a counter if already
 * exists. Int code, generated by an internal autoincrement pointer.
 * It’s a grow only object, entries can’t be removed.
 * There’s no method to put a term with a free code, terms are never replaced and
 * keep their code. Codes are kept consistent during all life of Object, but may
 * be lost on saving (TODO) and dictionary merges (TODO).
 * 
 * — TODO implement saving on SQL backend
 * — TODO dictionary merges
 * — TODO optimize double access ?
 * 
 * code->String->[code, counter, tag], access by code need another jump to get the tag.
 * 
 * A String can keep an int tag, set at creation of the entry but is not modified.
 * This could be used to filter dictionary outputs
 * (ex: just substantives, only nouns) with no more lexical informations about the Strings stored.
 * But be careful, this tag is not used as a component for the key.
 * This dictionary do not distinguish homographs by gramcat (same String key, different int tag).
 * The experience shows that a tag is usually not sufficient to distinguish linguistic homography
 * (ex: suis<VERB,être>, suis<VERB,suivre>.). 
 * An int field is not enough to ensure disambiguation between homographs, 
 * better approach is to forge String keys outside from this dictionary (ex: suis,être ; suis,suivre)
 * 
 * @author glorieux-f
 *
 */
public class TermDic
{
  /** 
   * HashMap to find by String. String is the best object for key (most common, not mutable).
   * A custom object (like Term) will not match against String.
   * The int array contains an int key and a count  
   */
  private HashMap<String,int[]> byTerm = new HashMap<String, int[]>();
  /** List of terms, kept in index order, to get a term by int index */
  private String[] byCode = new String[32];
  /** Position of the term index in the array of int values */
  public static final int ICODE = 0;
  /** Position of the tag info in the array of int values */
  public static final int ITAG = 1;
  /** Position of the term counter in the array of int values */
  public static final int ICOUNT = 2;
  /** Position of the second counter in the array of int values */
  public static final int ICOUNT2 = 3;
  /** Pointer in the array of terms, only growing when terms are added, used as code */
  private int pointer;
  /** Count of all occurrences for this dico */
  private long occs;
  /** Last occurrences count before some ops, for caching */
  // private int lastOccs;

  /**
   * Constructor
   */
  public TermDic()
  {
  }
  /**
   * Open a dictionary with a list of terms
   * @param terms
   */
  public TermDic( final String[] terms )
  {
    for (String term: terms) add( term, 0, 1, 0 );
  }
  /**
   * Erase all, for object reuse, and not too much memory reallocation.
   */
  public void clear()
  {
    occs=0;
    pointer = 0;
    byTerm.clear();
  }
  
  /**
   * Get a term by code
   * 
   * @param index
   * @return the term
   */
  public String term( final int code )
  {
    if (code < 1) return null;
    if (code > pointer) return null;
    return byCode[code];
  }

  /**
   * Get the code of a term, 0 if not found
   * 
   * @param term
   * @return the key
   */
  public int code( Term term )
  {
    int[] value = byTerm.get( term );
    if (value == null)
      return 0;
    return value[ICODE];
  }
  /**
   * Get the code of a term, 0 if not found
   * 
   * @param term
   * @return the key
   */
  public int code( String term )
  {
    int[] value = byTerm.get( term );
    if (value == null)
      return 0;
    return value[ICODE];
  }
  /**
   * Get the tag of a term, 0 if not found
   * 
   * @param term
   * @return the key
   */
  public int tag( Term term )
  {
    int[] value = byTerm.get( term );
    if (value == null)
      return 0;
    return value[ITAG];
  }
  /**
   * Get the code of a term, 0 if not found
   * 
   * @param term
   * @return the key
   */
  public int tag( String term )
  {
    int[] value = byTerm.get( term );
    if (value == null)
      return 0;
    return value[ITAG];
  }
  /**
   * Get the tag of a term by code, 0 if not found
   * 
   * @param code
   *          a term index
   * @return the state of counter after increments
   */
  public int tag( int code )
  {
    int[] value = byTerm.get( byCode[code] );
    if (value == null)
      return 0;
    return value[ITAG];
  }

  /**
   * Get the count for a term by String, 0 if not found
   * 
   * @param term
   * @return the count of occurrences
   */
  public int count( String term )
  {
    int[] value = byTerm.get( term );
    if (value == null)
      return 0;
    return value[ICOUNT];
  }
  
  /**
   * Get the count for a term by Term (a mutable String), 0 if not found
   * 
   * @param term
   * @return the count of occurrences
   */
  public int count( Term term )
  {
    int[] value = byTerm.get( term );
    if (value == null)
      return 0;
    return value[ICOUNT];
  }


  /**
   * Get the count of a term by code, 0 if not found
   * 
   * @param code
   *          a term index
   * @return the state of counter after increments
   */
  public int count( int code )
  {
    int[] value = byTerm.get( byCode[code] );
    if (value == null)
      return 0;
    return value[ICOUNT];
  }

  /**
   * Create a term with no tag, set its count at 1, or increment if exists
   * 
   * @param term a word
   * @return the code of term
   */
  public int inc( final String term )
  {
    return add( term, 0, 1, 0 );
  }
  /**
   * Create a term with no tag (by a Term object), set its count at 1, or increment if exists
   * 
   * @param term a word
   * @return the code of term
   */
  public int inc( final Term term )
  {
    return add( term, 0, 1, 0 );
  }
  /**
   * Increment second counter for a term (by a String object), or create it if not exists
   * 
   * @param term a word
   * @return the code of term
   */
  public int inc2( final String term )
  {
    return add( term, 0, 0, 1);
  }

  /**
   * Increment second counter for a term (by a Term object), or create it if not exists
   * 
   * @param term a word
   * @return the code of term
   */
  public int inc2( final Term term )
  {
    return add( term, 0, 0, 1);
  }

  /**
   * Create a term with a tag, set its count at 1, or increment if exists.
   * 
   * @param term a word
   * @param tag a category code
   * @return the code of term
   */
  public int inc( final String term, final int tag )
  {
    return add( term, tag, 1, 0 );
  }
  /**
   * Create a term with no tag (by a Term object), set its count at 1, or increment if exists.
   * 
   * @param term a word
   * @param tag a category code
   * @return the code of term
   */
  public int inc( final Term term, final int tag )
  {
    return add( term, tag, 1, 0 );
  }
  /**
   * Increment second counter for a term (by a String object), or create it if not exists
   * 
   * @param term a word
   * @return the code of term
   */
  public int inc2( final String term, final int tag )
  {
    return add( term, tag, 0, 1);
  }

  /**
   * Increment second counter for a term (by a Term object), or create it if not exists
   * 
   * @param term a word
   * @return the code of term
   */
  public int inc2( final Term term, final int tag )
  {
    return add( term, tag, 0, 1);
  }

  /**
   * Increment counter for a term (with a String object) of a specified amount, or create it if not exists
   * 
   * @param term a word
   * @param amount add to counter
   * @return the code of term
   */
  public int add( final String term, final int amount)
  {
    return add( term, 0, amount, 0 );
  }

  /**
   * Increment counter for a term (with a String object) of a specified amount, or create it if not exists
   * 
   * @param term a word
   * @param amount add to counter
   * @return the code of term
   */
  public int add( final Term term, final int amount)
  {
    return add( term, 0, amount, 0 );
  }

  /**
   * Increment counter for a term (with a String object) of a specified amount, or create it if not exists
   * 
   * @param term a word
   * @param amount add to counter
   * @return the code of term
   */
  public int add( final String term, final int tag, final int amount)
  {
    return add( term, tag, amount, 0 );
  }

  /**
   * Increment counter for a term (with a String object) of a specified amount, or create it if not exists
   * 
   * @param term a word
   * @param amount add to counter
   * @return the code of term
   */
  public int add( final Term term, final int tag, final int amount)
  {
    return add( term, tag, amount, 0 );
  }
  

  /**
   * Add a term occurrence, increment if exist or create entry
   * @param term
   * @param count1 for first counter
   * @param count2 for second counter
   * @return
   */
  public int add( final String term, final int tag, final int amount1, final int amount2 )
  {
    // this code is repeated to not copy the transmitted term 
    int[] value = byTerm.get( term );
    occs += amount1;
    occs += amount2;
    if (value == null) return put( term, tag, amount1, amount2);
    value[ICOUNT] += amount1;
    value[ICOUNT2] += amount2;
    return value[ICODE];
  }
  
  /**
   * Add a term occurrence, increment if exist or create entry, 
   * does not create a String object for increment, 
   * except if the entry is created.
   * 
   * @param term
   * @param count1 first count
   * @param count2 second counter
   * @return
   */
  public int add( final Term term, final int tag, final int amount, final int amount2 )
  {
    // this code is repeated to avoid the copy of 
    int[] value = byTerm.get( term );
    if (value == null) return put( term.toString(), tag, amount, amount2);
    occs += amount;
    occs += amount2;
    value[ICOUNT] += amount;
    value[ICOUNT2] += amount2;
    return value[ICODE];
  }
  /**
   * Create a term in the different data structures 
   * @param term
   * @param tag An int tag for output filtering
   * @param count initial value for counter  
   * @param count2 initial value for secondary counter
   * @return
   */
  private int put ( final String term, final int tag, final int amount, final int amount2 )
  {
    pointer++;
    // index is too short, extends it (not a big perf pb)
    if (pointer >= byCode.length) {
      final int oldLength = byCode.length;
      final String[] oldData = byCode;
      byCode = new String[Calcul.square2( oldLength )];
      System.arraycopy( oldData, 0, byCode, 0, oldLength );
    }
    byTerm.put( term, new int[] { pointer, tag, amount, amount2 } );
    byCode[pointer] = term;
    return pointer;
  }
  
  /**
   * Size of the dictionary
   */
  public int size()
  {
    return pointer;
  }

  /**
   * Sum of all counts
   */
  public long occs()
  {
    return occs;
  }
  /**
   * Increment occurrences count with not stored terms (useful for filtered dictionary)
   */
  public TermDic inc( )
  {
    occs ++;
    return this;
  }
  /**
   * Increment occurrences count with not stored terms (useful for filtered dictionary)
   */
  public TermDic inc( int i )
  {
    occs += i;
    return this;
  }
  /**
   * Get term list in inverse count order.
   * @return 
   */
  public String[] byCount()
  {
    return byCount( -1 );
  }
  /**
   * Not safe but useful to have a fast hand on data
   * @return the data
   */
  public Set<Map.Entry<String,int[]>> entrySet()
  {
    return byTerm.entrySet();
  }
  /**
   * Return an iterable object to get freqlist
   * Not clean, TODO better (Term API ?)
   * @return
   */
  public List<Map.Entry<String, int[]>> entriesByCount() {
    // Do not use LinkedList nere, very slow access by index list.get(i), arrayList is good
    List<Map.Entry<String, int[]>> list = new ArrayList<Map.Entry<String, int[]>>( byTerm.entrySet() );
    Collections.sort( list, new Comparator<Map.Entry<String, int[]>>() {
        @Override
        public int compare( Map.Entry<String, int[]> o1, Map.Entry<String, int[]> o2 ) {
          return (o2.getValue()[ICOUNT]+o2.getValue()[ICOUNT2]) - (o1.getValue()[ICOUNT] + o1.getValue()[ICOUNT2]);
        }
      } 
    );
    return list;
  }
  /**
   * Used for freqlist, return a view of the map sorted by term count
   * Shall we cache ?
   * What is better, Term or String ?
   * @param limit
   * @return
   */
  public String[] byCount(int limit)
  {
    // Do not use LinkedList nere, very slow access by index list.get(i), arrayList is good
    List<Map.Entry<String, int[]>> list = new ArrayList<Map.Entry<String, int[]>>( byTerm.entrySet() );
    Collections.sort( list, new Comparator<Map.Entry<String, int[]>>()
    {
      @Override
      public int compare( Map.Entry<String, int[]> o1, Map.Entry<String, int[]> o2 )
      {
        return (o2.getValue()[ICOUNT]+o2.getValue()[ICOUNT2]) - (o1.getValue()[ICOUNT] + o1.getValue()[ICOUNT2]);
      }
    } );
    int size = Math.min( list.size(), limit ) ;
    if ( limit < 1 ) size = list.size();
    String[] byCount = new String[size];
    for (int i = 0; i < size; i++) {
      byCount[i] = new String(list.get( i ).getKey()) ;
    }
    return byCount;
  }
  /**
   * 
   * @param limit
   * @return
   */
  public int[] codesByCount(int limit)
  {
    return null;
  }
  /**
   * To save the dictionary, with some index consistency but… will not works on
   * merge
   * 
   * @param file
   * @throws NumberFormatException
   * @throws IOException
   */
  public void csv( Path path ) throws IOException
  {
    BufferedWriter writer = Files.newBufferedWriter( path, Charset.forName( "UTF-8" ) );
    csv( writer );
  }

  /**
   * Send a CSV version of the dictionary
   * 
   * @return a CSV string
   */
  public String csv()
  {
    return csv( -1, null );
  }

  /**
   * Send a CSV version of the dictionary
   * 
   * @return a CSV string
   */
  public String csv( int limit )
  {
    return csv( limit, null );
  }

  /**
   * Send a CSV version of the dictionary
   * 
   * @return a CSV string
   */
  public String csv( int size, Set<Term> stoplist )
  {
    String ret = null;
    try {
      ret = csv( new StringWriter(), size, stoplist ).toString();
    } catch (IOException e) {
      e.printStackTrace();
    }
    return ret;
  }

  /**
   * Give a csv view of all dictionary
   * 
   * @throws IOException
   */
  public Writer csv( Writer writer ) throws IOException
  {
    return csv( writer, -1, null );
  }

  /**
   * Give a csv view of all dictionary
   * 
   * @throws IOException
   */
  public Writer csv( Writer writer, int limit, Set<Term> stoplist ) throws IOException
  {
    String[] byCount = byCount();
    int length = byCount.length;
    int count1;
    writer.write( "TERM\tCOUNT\tPPM\n" );
    try {
      for (int i = 0; i < length; i++) {
        if (stoplist != null && stoplist.contains( byCount[i] ))
          continue;
        if (limit-- == 0)
          break;
        int[] value = byTerm.get( byCount[i] );
        count1 = value[ICOUNT];
        writer.write( 
          byCount[i]
          +"\t"+ count1
          +"\t"+ (double)Math.round( 100000000.0*count1/occs )/100
        +"\n" );
      }
    } finally {
      writer.close();
    }
    return writer;
  }

  /**
   * DEPRECATED, use a CompDic nstead. 
   * Give a csv view of all dictionary
   * 
   * @throws IOException
   */
  public Writer csvcomp( Writer writer, int limit, Set<Term> stoplist ) throws IOException
  {
    String[] byCount = byCount();
    int length = byCount.length;
    int count1;
    int count2;
    try {
      for (int i = 0; i < length; i++) {
        if (stoplist != null && stoplist.contains( byCount[i] ))
          continue;
        if (limit-- == 0)
          break;
        int[] value = byTerm.get( byCount[i] );
        count1 = value[ICOUNT];
        count2 = value[ICOUNT2];
        writer.write( 
                byCount[i]
          +"\t"+ count1
          +"\t"+ count2
          +"\t"+ (count1+count2)
          +"\t"+NumberFormat.getInstance().format( 1.0*count1 / (count1+count2) )
          // +"\t"+index(byCount[i])
        +"\n" );
      }
    } finally {
      writer.close();
    }
    return writer;
  }

  /**
   * Is used for debug, is not a save method
   */
  @Override
  public String toString()
  {
    return csv( 10 );
  }

  /**
   * Load a freqlist from csv TODO test it
   * 
   * @param file
   * @throws IOException
   * @throws NumberFormatException
   */
  public void load( Path path ) throws IOException
  {
    BufferedReader reader = Files.newBufferedReader( path, Charset.forName( "UTF-8" ) );
    String line = null;
    int value;
    try {
      // pass first line
      line = reader.readLine();
      while ((line = reader.readLine()) != null) {
        if (line.contains( "\t" )) {
          String[] strings = line.split( "\t" );
          try {
            value = Integer.parseInt( strings[1] );
          } catch (NumberFormatException e) {
            continue;
          }
          add( strings[0].trim(), value );
        }
        else {
          inc( line.trim() );
        }
      }
    } finally {
      reader.close();
    }
  }

  /**
   * Testing
   * 
   * @throws IOException
   */
  public static void main( Term[] args ) throws IOException
  {
    String text = "un texte court avec un peu des mots un peu pareils des";
    // Term t = new Term();
    TermDic dic = new TermDic();
    for ( String s: text.split( " " ) ) {
      // t.replace( s ); // Mutable key is OK
      dic.inc( s );
    }
    System.out.println( dic );
    
  }
}
