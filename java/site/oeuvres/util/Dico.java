package site.oeuvres.util;

import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.IOException;
import java.io.StringWriter;
import java.io.Writer;
import java.nio.charset.Charset;
import java.nio.file.Files;
import java.nio.file.Path;
import java.text.NumberFormat;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.Comparator;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Set;

/**
 * A specialized table for a dictionary of terms with count and int key (starting at 1).
 * Access by String (internal HashMap), by an int key (internal array, for optimized vector).
 * Useful methods to get term list in inverse frequency order.
 * 
 * Each term added will create an entry or increment a counter if already
 * exists. Int id, generated by an internal autoincrement pointer.
 * It’s a grow only object, entries can’t be removed.
 * There’s no method to put a term with a free key, terms are never replaced and
 * keep their index. Ids are kept consistent during all life of Object, but may
 * be lost on saving (TODO) and dictionary merges (TODO).
 * 
 * TODO implement saving on SQL backend
 * 
 * @author glorieux-f
 *
 */
public class Dico
{
  /** Position of the term index in the array of int values */
  private static final int CODE = 0;
  /** Position of the term counter in the array of int values */
  private static final int COUNT1 = 1;
  /** Position of the second counter in the array of int values */
  private static final int COUNT2 = 2;
  /** Pointer in the array, only growing when terms are added, used as code */
  private int code;
  /** HashMap to find String fast, int array contains an int key and a count  */
  private HashMap<Term,int[]> byTerm;
  /** List of terms, kept in index order, to get a term by int index */
  private Term[] byIndex;
  /** Current working value */
  int[] value;
  /** Count of all occurrences */
  private int occs;
  /** Last occurrences count before some ops, for caching */
  // private int lastOccs;

  /**
   * Constructor
   */
  public Dico()
  {
    byTerm = new HashMap<Term, int[]>();
    byIndex = new Term[32];
  }

  
  /**
   * Get a term by index
   * Be Careful, returned term is mutable, modification will affect the dictionary.
   * Power is delicate.
   * 
   * @param index
   * @return the term
   */
  private Term term( final int index )
  {
    if (index < 1)
      return null;
    if (index > code)
      return null;
    return byIndex[index];
  }
  /**
   * Get a term by index 
   * @param index
   * @return The term as a string
   */
  public String string( final int index )
  {
    return term(index).toString();
  }

  /**
   * Get the index of a term, 0 if not found
   * 
   * @param term
   * @return the key
   */
  public int index( Term term )
  {
    value = byTerm.get( term );
    if (value == null)
      return 0;
    return value[CODE];
  }

  /**
   * Get the count of a term, 0 if not found
   * 
   * @param term
   * @return the count of occurrences
   */
  public int count( String term )
  {
    value = byTerm.get( term );
    if (value == null)
      return 0;
    return value[COUNT1];
  }

  /**
   * Get the count of a term by index, 0 if not found
   * 
   * @param index
   *          a term index
   * @return the state of counter after increments
   */
  public int count( int index )
  {
    value = byTerm.get( byIndex[index] );
    if (value == null)
      return 0;
    return value[COUNT1];
  }

  /**
   * Increment a term, create it if not exists
   * 
   * @param term
   * @return the index created
   */
  public int add( Term term )
  {
    return add( term, 1, 0 );
  }
  public int add2( Term term )
  {
    return add( term, 0, 1);
  }
  /**
   * Add a list of terms
   * 
   * @param term
   * @return better idea than void ?
   */
  /*
  public void add( String[] bag )
  {
    int length = bag.length;
    for ( int i=0; i<length; i++)
      add( bag[i], 1 );
  }
  */

  public int add ( final Term term, final int count)
  {
    return add( term, count, 0 );
  }
  /**
   * Multiple occurrences to add, return its index, increment counter if already
   * found here, be fast!
   */
  public int add( final Term term, final int count1, final int count2 )
  {
    value = byTerm.get( term );
    occs += count1;
    occs += count2;
    if (value == null) {
      // copy the transmitted term or it will be a mess
      return put ( new Term(term), count1, count2 );
    }
    value[COUNT1] += count1; // increment counter by reference
    value[COUNT2] += count2; // increment counter by reference
    return value[CODE];
  }
  
  private int put( final Term term, final int count1, final int count2 )
  {
    code++;
    // index is too short, extends it (not a big perf pb)
    if (code >= byIndex.length) {
      final int oldLength = byIndex.length;
      final Term[] oldData = byIndex;
      byIndex = new Term[oldLength * 2];
      System.arraycopy( oldData, 0, byIndex, 0, oldLength );
    }
    byTerm.put( term, new int[] { code, count1, count2 } );
    byIndex[code] = term;
    return code;
  }

  public int add( final String s, int count1, int count2 )
  {
    // this code is repeated to not copy the transmitted term 
    Term term = new Term( s );
    value = byTerm.get( term );
    occs += count1;
    occs += count2;
    if (value == null) {
      return put ( term, count1, count2 );
    }
    value[COUNT1] += count1;
    value[COUNT2] += count2;
    return value[CODE];
  }
  public int add( final String term, int count )
  {
    return add( term, count, 0);
  }
  public int add( final String term )
  {
    return add( term, 1, 0);
  }
  public int add2( final String term )
  {
    return add( term, 0, 1);
  }
  
  /**
   * Size of the dictionary
   */
  public int size()
  {
    return code;
  }

  /**
   * Sum of all counts
   */
  public int occs()
  {
    return occs;
  }
  /**
   * Get term list in inverse count order.
   * @return 
   */
  public Term[] byCount()
  {
    return byCount( -1 );
  }
  /**
   * Used for freqlist, return a view of the map sorted by term count
   * Shall we cache ?
   * @param limit
   * @return
   */
  public Term[] byCount(int limit)
  {
    // Do not use LinkedList nere, very slow access by index list.get(i), arrayList is good
    List<Map.Entry<Term, int[]>> list = new ArrayList<Map.Entry<Term, int[]>>( byTerm.entrySet() );
    Collections.sort( list, new Comparator<Map.Entry<Term, int[]>>()
    {
      @Override
      public int compare( Map.Entry<Term, int[]> o1, Map.Entry<Term, int[]> o2 )
      {
        return o2.getValue()[COUNT1] - o1.getValue()[COUNT1];
      }
    } );
    int size = Math.min( list.size(), limit ) ;
    if ( limit < 1 ) size = list.size();
    Term[] byCount = new Term[size];
    for (int i = 0; i < size; i++) {
      byCount[i] = new Term(list.get( i ).getKey()) ;
    }
    return byCount;
  }

  /**
   * To save the dictionary, with some index consistency but… will not works on
   * merge
   * 
   * @param file
   * @throws NumberFormatException
   * @throws IOException
   */
  public void csv( Path path ) throws IOException
  {
    BufferedWriter writer = Files.newBufferedWriter( path, Charset.forName( "UTF-8" ) );
    csv( writer );
  }

  /**
   * Send a CSV version of the dictionary
   * 
   * @return a CSV string
   */
  public String csv()
  {
    return csv( 0, null );
  }

  /**
   * Send a CSV version of the dictionary
   * 
   * @return a CSV string
   */
  public String csv( int limit )
  {
    return csv( limit, null );
  }

  /**
   * Send a CSV version of the dictionary
   * 
   * @return a CSV string
   */
  public String csv( int size, Set<String> stoplist )
  {
    String ret = null;
    try {
      ret = csv( new StringWriter(), size, stoplist ).toString();
    } catch (IOException e) {
      e.printStackTrace();
    }
    return ret;
  }

  /**
   * Give a csv view of all dictionary
   * 
   * @throws IOException
   */
  public Writer csv( Writer writer ) throws IOException
  {
    return csv( writer, -1, null );
  }

  /**
   * Give a csv view of all dictionary
   * 
   * @throws IOException
   */
  public Writer csv( Writer writer, int limit, Set<String> stoplist ) throws IOException
  {
    Term[] byCount = byCount();
    int length = byCount.length;
    int count;
    try {
      for (int i = 0; i < length; i++) {
        if (stoplist != null && stoplist.contains( byCount[i] ))
          continue;
        if (limit-- == 0)
          break;
        int[] value = byTerm.get( byCount[i] );
        writer.write( 
                byCount[i]
          +"\t"+value[COUNT1]
          +"\t"+value[COUNT2]
          +"\t"+NumberFormat.getInstance().format( 1.0*(value[COUNT1]-value[COUNT2]) / (value[COUNT1]+value[COUNT2]) )
          // +"\t"+index(byCount[i])
        +"\n" );
      }
    } finally {
      writer.close();
    }
    return writer;
  }

  /**
   * Is used for debug, is not a save method
   */
  @Override
  public String toString()
  {
    return csv( 10 );
  }

  /**
   * Load a freqlist from csv TODO test it
   * 
   * @param file
   * @throws IOException
   * @throws NumberFormatException
   */
  public void load( Path path ) throws IOException
  {
    BufferedReader reader = Files.newBufferedReader( path, Charset.forName( "UTF-8" ) );
    String line = null;
    int value;
    try {
      // pass first line
      line = reader.readLine();
      while ((line = reader.readLine()) != null) {
        if (line.contains( "\t" )) {
          String[] strings = line.split( "\t" );
          try {
            value = Integer.parseInt( strings[1] );
          } catch (NumberFormatException e) {
            continue;
          }
          add( strings[0].trim(), value );
        }
        else {
          add( line.trim() );
        }
      }
    } finally {
      reader.close();
    }
  }

  /**
   * Testing
   * 
   * @throws IOException
   */
  public static void main( String[] args ) throws IOException
  {
    String text = "un texte court avec un peu des mots un peu pareils des";
    // Term t = new Term();
    Dico dic = new Dico();
    for ( String s: text.split( " " ) ) {
      // t.replace( s ); // Mutable key is OK
      dic.add( s );
    }
    System.out.println( dic );
    
  }
}
