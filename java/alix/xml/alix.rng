<?xml version="1.0" encoding="UTF-8"?>
<grammar
  xmlns="http://relaxng.org/ns/structure/1.0" 
  ns="http://alix.casa" 
  datatypeLibrary="http://www.w3.org/2001/XMLSchema-datatypes"
  xml:lang="en"
  xmlns:a="http://relaxng.org/ns/compatibility/annotations/1.0" 
  xmlns:h="http://www.w3.org/1999/xhtml"
>
  <a:documentation>Alix, schema of xml to ingest</a:documentation>
  <div xmlns="http://www.w3.org/1999/xhtml">
    <p>
This schema define the XML tags understood by Alix to ingest text document (articles, books…).
As a lucene indexing platform, Alix borrows some concepts from <a href="https://lucene.apache.org/solr/">Solr</a>,
but dedicated to text, defining an index schema is easier with Alix. The proposed field types 
are designed to answer to a need, not to replicate Lucene API complexity.
Investigations have been done, you have the best of a Lucene for texts.
    </p>
    <p>
According to Lucene model, there are 3 levels of objects inside Alix.
    </p>
    <ul>
      <li><a:el>field</a:el>, corresponding to a lucene 
        <a href="https://lucene.apache.org/core/8_2_0/core/org/apache/lucene/document/Field.html">Field</a>.
        A field has a name, a type, and a content.
        Alix defines a limited set of types, dedicated to text documents, content depends on type.
      </li>
      <li><a:el>document</a:el>, a set of <a:el>field</a:el>s corresponding to a lucene 
        <a href="https://lucene.apache.org/core/8_2_0/core/org/apache/lucene/document/Document.html">Document</a>
      </li>
      <li><a:el>book</a:el>, a set of <a:el>chapter</a:el>s, 
        corresponding to an advance feature in lucene, allowing to index a group of Document objects,
        with a specefic one used as a cover
        <a href="https://lucene.apache.org/core/8_2_0/core/org/apache/lucene/index/IndexWriter.html#addDocuments-java.lang.Iterable-">IndexReader.addDocuments()</a>.
        A book is a useful unit in Alix for faceting results, or defining a corpus.
        For Lucene, a <a:el>chapter</a:el> is like a document 
        A simple article is not required to be inside a book, <a:el>document</a:el> are allowed.
      </li>
    </ul>
    <!--
    <p>
Because Alix is designed for XML documents, it allows  
(unlike other tools like <a href="https://lucene.apache.org/solr/">Solr</a>,
Alix do not index only text, but also structured documents with xml/xhtml tags. 
Tags are not searchable, but they are kept and displayed.
The indexing process will keep precise memory of offsets of each token inside the tags, 
so that word found can be hilited in a document without breaking its structure.
    </p>
    <p>
Alix is dedicated to text documents, it provides dedicated set of fields 
    </p>
    -->
  </div>
  <start>
    <a:documentation>The root element could be a single <a:el>document</a:el>, a <a:el>book</a:el>, or 
      a <a:el>set</a:el> (containing <a:el>document</a:el>s and <a:el>book</a:el>s).</a:documentation>
    <choice>
      <ref name="set"/>
      <ref name="book"/>
      <ref name="document"/>
    </choice>
  </start>
  <define name="set">
    <element name="set">
      <a:documentation>A set of <a:el>book</a:el> or <a:el>document</a:el>.</a:documentation>
      <oneOrMore>
        <choice>
          <ref name="book"/>
          <ref name="document"/>
        </choice>
      </oneOrMore>
    </element>
  </define>
  <define name="book">
    <element name="book">
      <a:documentation>A set of <a:el>chapter</a:el>s with shared <a:el>field</a:el>s (ex: title, author, date…)</a:documentation>
      <attribute name="xml:id">
        <a:documentation>String identifier for the book.</a:documentation>
      </attribute>
      <oneOrMore>
        <choice>
          <ref name="field"/>
          <ref name="chapter"/>
        </choice>
      </oneOrMore>
    </element>
  </define>
  <define name="chapter">
    <element name="chapter">
      <a:documentation>A set of <a:el>field</a:el>s, like a <a:el>document</a:el>, except it has to be inside a <a:el>book</a:el>.</a:documentation>
      <oneOrMore>
        <ref name="field"/>
      </oneOrMore>
    </element>
  </define>
  <define name="document">
    <element name="document">
      <a:documentation>A set of <a:el>field</a:el>s.</a:documentation>
      <oneOrMore>
        <ref name="field"/>
      </oneOrMore>
    </element>
  </define>
  <define name="field">
    <choice>
      <ref name="field-text"/>
      <ref name="field-meta"/>
      <ref name="field-store"/>
      <ref name="field-int"/>
      <ref name="field-facet"/>
      <ref name="field-facets"/>
    </choice>
  </define>
  <define name="field-text">
    <element name="field">
      <a:documentation>
Text to search with advanced lexical features (lemma, co-occurrences…).
XML tags are allowed, well-formedness is not required, so HTML ready to display could be sent.
Content is also available as a stored field for display, hilite of occurrences found, relevant excerpts.
This type is quite heavy (positions, offsets, term vectors…).
If you need a simple token search, prefer @type="meta".
      </a:documentation>
      <ref name="name"/>
      <attribute name="type">
        <value>text</value>
      </attribute>
      <ref name="xml"/>
    </element>
  </define>
  <define name="field-meta">
    <element name="field">
      <a:documentation>
Some text (or xml) to search as raw tokens without linguistic feature. Is especially useful to search 
in bibliographic records by token.
      </a:documentation>
      <ref name="name"/>
      <attribute name="type">
        <value>meta</value>
      </attribute>
      <choice>
        <attribute name="value"/>
        <ref name="xml"/>
      </choice>
    </element>
  </define>
  <define name="field-store">
    <element name="field">
      <a:documentation>Content to store (not for search nor sorting), maybe a text value in the @value attribute, or an xml content nested. 
        Stored values can be retrieved in search results (ex: url), or as an annex for a full document view (ex: table of contents).</a:documentation>
      <ref name="name"/>
      <attribute name="type">
        <value>store</value>
      </attribute>
      <choice>
        <attribute name="value"/>
        <ref name="xml"/>
      </choice>
    </element>
  </define>
  <define name="field-int">
    <element name="field">
      <a:documentation>A signed integer value, unique for a field name by document (ex: date), used for sorting, queries, or retrieve (also available as a stored field).</a:documentation>
      <ref name="name"/>
      <attribute name="type">
        <value>int</value>
      </attribute>
      <attribute name="value">
        <data type="int"/>
      </attribute>
    </element>
  </define>
  <define name="field-facet">
    <element name="field">
      <a:documentation>A term, unique for field name by document (ex: title), used as a classifier (also available for retrieve as a stored field).</a:documentation>
      <ref name="name"/>
      <attribute name="type">
        <value>facet</value>
      </attribute>
      <attribute name="value"/>
    </element>
  </define>
  <define name="field-facets">
    <element name="field">
      <a:documentation>Set of terms by document (ex: author) used as a classifier for the collection (also available for retrieve as a stored field).</a:documentation>
      <ref name="name"/>
      <attribute name="type">
        <value>facets</value>
      </attribute>
      <attribute name="value"/>
    </element>
  </define>
  <define name="name">
    <attribute name="name">
      <data type="Name"/>
    </attribute>
  </define>
  <define name="xml">
    <oneOrMore>
      <choice>
        <text/>
        <ref name="el"/>
      </choice>
    </oneOrMore>
  </define>
  <define name="el">
    <element>
      <anyName/>
      <zeroOrMore>
        <choice>
          <attribute>
            <anyName/>
          </attribute>
          <text/>
          <ref name="el"/>
        </choice>
      </zeroOrMore>
    </element>
  </define>
</grammar>